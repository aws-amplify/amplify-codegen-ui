// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`amplify form renderer tests datastore form tests custom form tests should render a custom backed form 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  Radio,
  RadioGroupField,
  SelectField,
  StepperField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
export default function CustomDataForm(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const initialValues = {
    name: undefined,
    email: undefined,
    city: undefined,
    category: undefined,
    pages: 0,
    phone: undefined,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [email, setEmail] = React.useState(initialValues.email);
  const [city, setCity] = React.useState(initialValues.city);
  const [category, setCategory] = React.useState(initialValues.category);
  const [pages, setPages] = React.useState(initialValues.pages);
  const [phone, setPhone] = React.useState(initialValues.phone);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setEmail(initialValues.email);
    setCity(initialValues.city);
    setCategory(initialValues.category);
    setPages(initialValues.pages);
    setPhone(initialValues.phone);
    setErrors({});
  };
  const validations = {
    name: [{ type: \\"Required\\" }],
    email: [{ type: \\"Required\\" }],
    city: [],
    category: [],
    pages: [],
    phone: [{ type: \\"Required\\" }, { type: \\"Phone\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
          email,
          city,
          category,
          pages,
          phone,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomDataForm\\")}
    >
      <TextField
        label=\\"name\\"
        isRequired={true}
        defaultValue=\\"John Doe\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              email,
              city,
              category,
              pages,
              phone,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <TextField
        label=\\"E-mail\\"
        isRequired={true}
        defaultValue=\\"johndoe@amplify.com\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email: value,
              city,
              category,
              pages,
              phone,
            };
            const result = onChange(modelFields);
            value = result?.email ?? value;
          }
          if (errors.email?.hasError) {
            runValidationTasks(\\"email\\", value);
          }
          setEmail(value);
        }}
        onBlur={() => runValidationTasks(\\"email\\", email)}
        errorMessage={errors.email?.errorMessage}
        hasError={errors.email?.hasError}
        {...getOverrideProps(overrides, \\"email\\")}
      ></TextField>
      <SelectField
        label=\\"Label\\"
        placeholder=\\"Please select an option\\"
        value={city}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city: value,
              category,
              pages,
              phone,
            };
            const result = onChange(modelFields);
            value = result?.city ?? value;
          }
          if (errors.city?.hasError) {
            runValidationTasks(\\"city\\", value);
          }
          setCity(value);
        }}
        onBlur={() => runValidationTasks(\\"city\\", city)}
        errorMessage={errors.city?.errorMessage}
        hasError={errors.city?.hasError}
        {...getOverrideProps(overrides, \\"city\\")}
      >
        <option
          children=\\"Los Angeles\\"
          value=\\"Los Angeles\\"
          {...getOverrideProps(overrides, \\"cityoption0\\")}
        ></option>
        <option
          children=\\"Houston\\"
          value=\\"Houston\\"
          {...getOverrideProps(overrides, \\"cityoption1\\")}
        ></option>
        <option
          children=\\"New York\\"
          value=\\"New York\\"
          selected={true}
          {...getOverrideProps(overrides, \\"cityoption2\\")}
        ></option>
      </SelectField>
      <RadioGroupField
        label=\\"Label\\"
        name=\\"fieldName\\"
        defaultValue=\\"Hobbies\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category: value,
              pages,
              phone,
            };
            const result = onChange(modelFields);
            value = result?.category ?? value;
          }
          if (errors.category?.hasError) {
            runValidationTasks(\\"category\\", value);
          }
          setCategory(value);
        }}
        onBlur={() => runValidationTasks(\\"category\\", category)}
        errorMessage={errors.category?.errorMessage}
        hasError={errors.category?.hasError}
        {...getOverrideProps(overrides, \\"category\\")}
      >
        <Radio
          children=\\"Hobbies\\"
          value=\\"Hobbies\\"
          {...getOverrideProps(overrides, \\"categoryRadio0\\")}
        ></Radio>
        <Radio
          children=\\"Travel\\"
          value=\\"Travel\\"
          {...getOverrideProps(overrides, \\"categoryRadio1\\")}
        ></Radio>
        <Radio
          children=\\"Health\\"
          value=\\"Health\\"
          {...getOverrideProps(overrides, \\"categoryRadio2\\")}
        ></Radio>
      </RadioGroupField>
      <StepperField
        label=\\"Label\\"
        value={pages}
        onStepChange={(e) => {
          let value = e;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category,
              pages: value,
              phone,
            };
            const result = onChange(modelFields);
            value = result?.pages ?? value;
          }
          if (errors.pages?.hasError) {
            runValidationTasks(\\"pages\\", value);
          }
          setPages(value);
        }}
        onBlur={() => runValidationTasks(\\"pages\\", pages)}
        errorMessage={errors.pages?.errorMessage}
        hasError={errors.pages?.hasError}
        {...getOverrideProps(overrides, \\"pages\\")}
      ></StepperField>
      <TextField
        label=\\"Phone Number\\"
        isRequired={true}
        defaultValue=\\"+1-401-152-6995\\"
        type=\\"tel\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category,
              pages,
              phone: value,
            };
            const result = onChange(modelFields);
            value = result?.phone ?? value;
          }
          if (errors.phone?.hasError) {
            runValidationTasks(\\"phone\\", value);
          }
          setPhone(value);
        }}
        onBlur={() => runValidationTasks(\\"phone\\", phone)}
        errorMessage={errors.phone?.errorMessage}
        hasError={errors.phone?.hasError}
        {...getOverrideProps(overrides, \\"phone\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"empty\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"go back\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"create\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a custom backed form 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, RadioGroupFieldProps, SelectFieldProps, StepperFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type CustomDataFormInputValues = {
    name?: string;
    email?: string;
    city?: string;
    category?: string;
    pages?: number;
    phone?: string;
};
export declare type CustomDataFormValidationValues = {
    name?: ValidationFunction<string>;
    email?: ValidationFunction<string>;
    city?: ValidationFunction<string>;
    category?: ValidationFunction<string>;
    pages?: ValidationFunction<number>;
    phone?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomDataFormOverridesProps = {
    CustomDataFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    email?: FormProps<TextFieldProps>;
    city?: FormProps<SelectFieldProps>;
    category?: FormProps<RadioGroupFieldProps>;
    pages?: FormProps<StepperFieldProps>;
    phone?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type CustomDataFormProps = React.PropsWithChildren<{
    overrides?: CustomDataFormOverridesProps | undefined | null;
} & {
    onSubmit: (fields: CustomDataFormInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomDataFormInputValues) => CustomDataFormInputValues;
    onValidate?: CustomDataFormValidationValues;
} & React.CSSProperties>;
export default function CustomDataForm(props: CustomDataFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a custom backed form 3`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  Radio,
  RadioGroupField,
  SelectField,
  StepperField,
  TextAreaField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
export default function CustomDataForm(props) {
  const {
    initialData,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    name: undefined,
    email: undefined,
    \\"metadata-field\\": undefined,
    city: undefined,
    category: undefined,
    pages: 0,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [email, setEmail] = React.useState(initialValues.email);
  const [metadataField, setMetadataField] = React.useState(
    initialValues[\\"metadata-field\\"]
  );
  const [city, setCity] = React.useState(initialValues.city);
  const [category, setCategory] = React.useState(initialValues.category);
  const [pages, setPages] = React.useState(initialValues.pages);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    const cleanValues = { ...initialValues, ...initialData };
    setName(cleanValues.name);
    setEmail(cleanValues.email);
    setMetadataField(cleanValues[\\"metadata-field\\"]);
    setCity(cleanValues.city);
    setCategory(cleanValues.category);
    setPages(cleanValues.pages);
    setErrors({});
  };
  React.useEffect(resetStateValues, [initialData]);
  React.useEffect(() => {
    if (initialData) {
      setName(initialData.name);
      setEmail(initialData.email);
      setMetadataField(initialData[\\"metadata-field\\"]);
      setCity(initialData.city);
      setCategory(initialData.category);
      setPages(initialData.pages);
    }
  }, []);
  const validations = {
    name: [{ type: \\"Required\\" }],
    email: [{ type: \\"Required\\" }],
    \\"metadata-field\\": [{ type: \\"Required\\" }, { type: \\"JSON\\" }],
    city: [],
    category: [],
    pages: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
          email,
          \\"metadata-field\\": metadataField,
          city,
          category,
          pages,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomDataForm\\")}
    >
      <TextField
        label=\\"name\\"
        isRequired={true}
        defaultValue=\\"John Doe\\"
        defaultValue={name}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              email,
              \\"metadata-field\\": metadataField,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <TextField
        label=\\"E-mail\\"
        isRequired={true}
        defaultValue=\\"johndoe@amplify.com\\"
        defaultValue={email}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email: value,
              \\"metadata-field\\": metadataField,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.email ?? value;
          }
          if (errors.email?.hasError) {
            runValidationTasks(\\"email\\", value);
          }
          setEmail(value);
        }}
        onBlur={() => runValidationTasks(\\"email\\", email)}
        errorMessage={errors.email?.errorMessage}
        hasError={errors.email?.hasError}
        {...getOverrideProps(overrides, \\"email\\")}
      ></TextField>
      <TextAreaField
        label=\\"Metadata\\"
        isRequired={true}
        defaultValue={metadataField}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              \\"metadata-field\\": value,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.[\\"metadata-field\\"] ?? value;
          }
          if (errors[\\"metadata-field\\"]?.hasError) {
            runValidationTasks(\\"metadata-field\\", value);
          }
          setMetadataField(value);
        }}
        onBlur={() => runValidationTasks(\\"metadata-field\\", metadataField)}
        errorMessage={errors[\\"metadata-field\\"]?.errorMessage}
        hasError={errors[\\"metadata-field\\"]?.hasError}
        {...getOverrideProps(overrides, \\"metadata-field\\")}
      ></TextAreaField>
      <SelectField
        label=\\"Label\\"
        placeholder=\\"Please select an option\\"
        value={city}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              \\"metadata-field\\": metadataField,
              city: value,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.city ?? value;
          }
          if (errors.city?.hasError) {
            runValidationTasks(\\"city\\", value);
          }
          setCity(value);
        }}
        onBlur={() => runValidationTasks(\\"city\\", city)}
        errorMessage={errors.city?.errorMessage}
        hasError={errors.city?.hasError}
        {...getOverrideProps(overrides, \\"city\\")}
      >
        <option
          children=\\"Los Angeles\\"
          value=\\"Los Angeles\\"
          {...getOverrideProps(overrides, \\"cityoption0\\")}
        ></option>
        <option
          children=\\"Houston\\"
          value=\\"Houston\\"
          {...getOverrideProps(overrides, \\"cityoption1\\")}
        ></option>
        <option
          children=\\"New York\\"
          value=\\"New York\\"
          selected={true}
          {...getOverrideProps(overrides, \\"cityoption2\\")}
        ></option>
      </SelectField>
      <RadioGroupField
        label=\\"Label\\"
        name=\\"fieldName\\"
        defaultValue=\\"Hobbies\\"
        defaultValue={category}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              \\"metadata-field\\": metadataField,
              city,
              category: value,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.category ?? value;
          }
          if (errors.category?.hasError) {
            runValidationTasks(\\"category\\", value);
          }
          setCategory(value);
        }}
        onBlur={() => runValidationTasks(\\"category\\", category)}
        errorMessage={errors.category?.errorMessage}
        hasError={errors.category?.hasError}
        {...getOverrideProps(overrides, \\"category\\")}
      >
        <Radio
          children=\\"Hobbies\\"
          value=\\"Hobbies\\"
          {...getOverrideProps(overrides, \\"categoryRadio0\\")}
        ></Radio>
        <Radio
          children=\\"Travel\\"
          value=\\"Travel\\"
          {...getOverrideProps(overrides, \\"categoryRadio1\\")}
        ></Radio>
        <Radio
          children=\\"Health\\"
          value=\\"Health\\"
          {...getOverrideProps(overrides, \\"categoryRadio2\\")}
        ></Radio>
      </RadioGroupField>
      <StepperField
        label=\\"Label\\"
        value={pages}
        onStepChange={(e) => {
          let value = e;
          if (onChange) {
            const modelFields = {
              name,
              email,
              \\"metadata-field\\": metadataField,
              city,
              category,
              pages: value,
            };
            const result = onChange(modelFields);
            value = result?.pages ?? value;
          }
          if (errors.pages?.hasError) {
            runValidationTasks(\\"pages\\", value);
          }
          setPages(value);
        }}
        onBlur={() => runValidationTasks(\\"pages\\", pages)}
        errorMessage={errors.pages?.errorMessage}
        hasError={errors.pages?.hasError}
        {...getOverrideProps(overrides, \\"pages\\")}
      ></StepperField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"empty\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ResetButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"go back\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"create\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a custom backed form 4`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, RadioGroupFieldProps, SelectFieldProps, StepperFieldProps, TextAreaFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type CustomDataFormInputValues = {
    name?: string;
    email?: string;
    \\"metadata-field\\"?: string;
    city?: string;
    category?: string;
    pages?: number;
};
export declare type CustomDataFormValidationValues = {
    name?: ValidationFunction<string>;
    email?: ValidationFunction<string>;
    \\"metadata-field\\"?: ValidationFunction<string>;
    city?: ValidationFunction<string>;
    category?: ValidationFunction<string>;
    pages?: ValidationFunction<number>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomDataFormOverridesProps = {
    CustomDataFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    email?: FormProps<TextFieldProps>;
    \\"metadata-field\\"?: FormProps<TextAreaFieldProps>;
    city?: FormProps<SelectFieldProps>;
    category?: FormProps<RadioGroupFieldProps>;
    pages?: FormProps<StepperFieldProps>;
} & EscapeHatchProps;
export declare type CustomDataFormProps = React.PropsWithChildren<{
    overrides?: CustomDataFormOverridesProps | undefined | null;
} & {
    initialData?: CustomDataFormInputValues;
    onSubmit: (fields: CustomDataFormInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomDataFormInputValues) => CustomDataFormInputValues;
    onValidate?: CustomDataFormValidationValues;
} & React.CSSProperties>;
export default function CustomDataForm(props: CustomDataFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a custom backed form with an array field 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function CustomDataForm(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const initialValues = {
    name: undefined,
    email: [],
    phone: [],
  };
  const [name, setName] = React.useState(initialValues.name);
  const [email, setEmail] = React.useState(initialValues.email);
  const [phone, setPhone] = React.useState(initialValues.phone);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setEmail(initialValues.email);
    setCurrentEmailValue(undefined);
    setPhone(initialValues.phone);
    setCurrentPhoneValue(undefined);
    setErrors({});
  };
  const [currentEmailValue, setCurrentEmailValue] = React.useState(undefined);
  const emailRef = React.createRef();
  const [currentPhoneValue, setCurrentPhoneValue] = React.useState(undefined);
  const phoneRef = React.createRef();
  const validations = {
    name: [{ type: \\"Required\\" }],
    email: [{ type: \\"Required\\" }],
    phone: [{ type: \\"Required\\" }, { type: \\"Phone\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
          email,
          phone,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomDataForm\\")}
    >
      <TextField
        label=\\"name\\"
        isRequired={true}
        defaultValue=\\"John Doe\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              email,
              phone,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              name,
              email: values,
              phone,
            };
            const result = onChange(modelFields);
            values = result?.email ?? values;
          }
          setEmail(values);
          setCurrentEmailValue(undefined);
        }}
        currentFieldValue={currentEmailValue}
        label={\\"E-mail\\"}
        items={email}
        hasError={errors.email?.hasError}
        setFieldValue={setCurrentEmailValue}
        inputFieldRef={emailRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"E-mail\\"
          isRequired={true}
          defaultValue=\\"johndoe@amplify.com\\"
          value={currentEmailValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.email?.hasError) {
              runValidationTasks(\\"email\\", value);
            }
            setCurrentEmailValue(value);
          }}
          onBlur={() => runValidationTasks(\\"email\\", currentEmailValue)}
          errorMessage={errors.email?.errorMessage}
          hasError={errors.email?.hasError}
          ref={emailRef}
          {...getOverrideProps(overrides, \\"email\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              name,
              email,
              phone: values,
            };
            const result = onChange(modelFields);
            values = result?.phone ?? values;
          }
          setPhone(values);
          setCurrentPhoneValue(undefined);
        }}
        currentFieldValue={currentPhoneValue}
        label={\\"phone\\"}
        items={phone}
        hasError={errors.phone?.hasError}
        setFieldValue={setCurrentPhoneValue}
        inputFieldRef={phoneRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"phone\\"
          isRequired={true}
          defaultValue=\\"+1-401-152-6995\\"
          type=\\"tel\\"
          value={currentPhoneValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.phone?.hasError) {
              runValidationTasks(\\"phone\\", value);
            }
            setCurrentPhoneValue(value);
          }}
          onBlur={() => runValidationTasks(\\"phone\\", currentPhoneValue)}
          errorMessage={errors.phone?.errorMessage}
          hasError={errors.phone?.hasError}
          ref={phoneRef}
          {...getOverrideProps(overrides, \\"phone\\")}
        ></TextField>
      </ArrayField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"empty\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"go back\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"create\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a custom backed form with an array field 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type CustomDataFormInputValues = {
    name?: string;
    email?: string[];
    phone?: string[];
};
export declare type CustomDataFormValidationValues = {
    name?: ValidationFunction<string>;
    email?: ValidationFunction<string>;
    phone?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomDataFormOverridesProps = {
    CustomDataFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    email?: FormProps<TextFieldProps>;
    phone?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type CustomDataFormProps = React.PropsWithChildren<{
    overrides?: CustomDataFormOverridesProps | undefined | null;
} & {
    onSubmit: (fields: CustomDataFormInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomDataFormInputValues) => CustomDataFormInputValues;
    onValidate?: CustomDataFormValidationValues;
} & React.CSSProperties>;
export default function CustomDataForm(props: CustomDataFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a datastore backed form with a custom array field 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextAreaField,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function MyPostForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    username: undefined,
    caption: undefined,
    Customtags: [],
    post_url: undefined,
    metadata: undefined,
    profile_url: undefined,
  };
  const [username, setUsername] = React.useState(initialValues.username);
  const [caption, setCaption] = React.useState(initialValues.caption);
  const [Customtags, setCustomtags] = React.useState(initialValues.Customtags);
  const [post_url, setPost_url] = React.useState(initialValues.post_url);
  const [metadata, setMetadata] = React.useState(
    initialValues.metadata ? JSON.stringify(initialValues.metadata) : undefined
  );
  const [profile_url, setProfile_url] = React.useState(
    initialValues.profile_url
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setUsername(initialValues.username);
    setCaption(initialValues.caption);
    setCustomtags(initialValues.Customtags);
    setCurrentCustomtagsValue(undefined);
    setPost_url(initialValues.post_url);
    setMetadata(initialValues.metadata);
    setProfile_url(initialValues.profile_url);
    setErrors({});
  };
  const [currentCustomtagsValue, setCurrentCustomtagsValue] =
    React.useState(undefined);
  const CustomtagsRef = React.createRef();
  const validations = {
    username: [
      {
        type: \\"GreaterThanChar\\",
        numValues: [2],
        validationMessage: \\"needs to be of length 2\\",
      },
    ],
    caption: [],
    Customtags: [],
    post_url: [{ type: \\"URL\\" }],
    metadata: [{ type: \\"JSON\\" }],
    profile_url: [{ type: \\"URL\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          username,
          caption,
          Customtags,
          post_url: post_url || undefined,
          metadata,
          profile_url: profile_url || undefined,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Post(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyPostForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <Grid
        columnGap=\\"inherit\\"
        rowGap=\\"inherit\\"
        templateColumns=\\"repeat(2, auto)\\"
        {...getOverrideProps(overrides, \\"RowGrid0\\")}
      >
        <TextField
          label=\\"Username\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"john\\"
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username: value,
                caption,
                Customtags,
                post_url,
                metadata,
                profile_url,
              };
              const result = onChange(modelFields);
              value = result?.username ?? value;
            }
            if (errors.username?.hasError) {
              runValidationTasks(\\"username\\", value);
            }
            setUsername(value);
          }}
          onBlur={() => runValidationTasks(\\"username\\", username)}
          errorMessage={errors.username?.errorMessage}
          hasError={errors.username?.hasError}
          {...getOverrideProps(overrides, \\"username\\")}
        ></TextField>
        <TextField
          label=\\"Caption\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"i love code\\"
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username,
                caption: value,
                Customtags,
                post_url,
                metadata,
                profile_url,
              };
              const result = onChange(modelFields);
              value = result?.caption ?? value;
            }
            if (errors.caption?.hasError) {
              runValidationTasks(\\"caption\\", value);
            }
            setCaption(value);
          }}
          onBlur={() => runValidationTasks(\\"caption\\", caption)}
          errorMessage={errors.caption?.errorMessage}
          hasError={errors.caption?.hasError}
          {...getOverrideProps(overrides, \\"caption\\")}
        ></TextField>
      </Grid>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags: values,
              post_url,
              metadata,
              profile_url,
            };
            const result = onChange(modelFields);
            values = result?.Customtags ?? values;
          }
          setCustomtags(values);
          setCurrentCustomtagsValue(undefined);
        }}
        currentFieldValue={currentCustomtagsValue}
        label={\\"Tags\\"}
        items={Customtags}
        hasError={errors.Customtags?.hasError}
        setFieldValue={setCurrentCustomtagsValue}
        inputFieldRef={CustomtagsRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Tags\\"
          placeholder=\\"goals\\"
          value={currentCustomtagsValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.Customtags?.hasError) {
              runValidationTasks(\\"Customtags\\", value);
            }
            setCurrentCustomtagsValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"Customtags\\", currentCustomtagsValue)
          }
          errorMessage={errors.Customtags?.errorMessage}
          hasError={errors.Customtags?.hasError}
          ref={CustomtagsRef}
          {...getOverrideProps(overrides, \\"Customtags\\")}
        ></TextField>
      </ArrayField>
      <TextField
        label=\\"Post url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              post_url: value,
              metadata,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <TextAreaField
        label=\\"Metadata\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              post_url,
              metadata: value,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.metadata ?? value;
          }
          if (errors.metadata?.hasError) {
            runValidationTasks(\\"metadata\\", value);
          }
          setMetadata(value);
        }}
        onBlur={() => runValidationTasks(\\"metadata\\", metadata)}
        errorMessage={errors.metadata?.errorMessage}
        hasError={errors.metadata?.hasError}
        {...getOverrideProps(overrides, \\"metadata\\")}
      ></TextAreaField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              post_url,
              metadata,
              profile_url: value,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render a datastore backed form with a custom array field 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextAreaFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyPostFormInputValues = {
    username?: string;
    caption?: string;
    Customtags?: string[];
    post_url?: string;
    metadata?: string;
    profile_url?: string;
};
export declare type MyPostFormValidationValues = {
    username?: ValidationFunction<string>;
    caption?: ValidationFunction<string>;
    Customtags?: ValidationFunction<string>;
    post_url?: ValidationFunction<string>;
    metadata?: ValidationFunction<string>;
    profile_url?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyPostFormOverridesProps = {
    MyPostFormGrid?: FormProps<GridProps>;
    RowGrid0?: FormProps<GridProps>;
    username?: FormProps<TextFieldProps>;
    caption?: FormProps<TextFieldProps>;
    Customtags?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
    metadata?: FormProps<TextAreaFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type MyPostFormProps = React.PropsWithChildren<{
    overrides?: MyPostFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onSuccess?: (fields: MyPostFormInputValues) => void;
    onError?: (fields: MyPostFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onValidate?: MyPostFormValidationValues;
} & React.CSSProperties>;
export default function MyPostForm(props: MyPostFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render nested json fields 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Heading,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function NestedJson(props) {
  const { onSubmit, onValidate, onChange, overrides, ...rest } = props;
  const { tokens } = useTheme();
  const initialValues = {
    \\"first-Name\\": undefined,
    lastName: undefined,
    bio: {},
    Nicknames1: [],
    \\"nick-names2\\": [],
    \\"first Name\\": undefined,
  };
  const [firstName, setFirstName] = React.useState(initialValues[\\"first-Name\\"]);
  const [lastName, setLastName] = React.useState(initialValues.lastName);
  const [bio, setBio] = React.useState(initialValues.bio);
  const [Nicknames1, setNicknames1] = React.useState(initialValues.Nicknames1);
  const [nickNames, setNickNames] = React.useState(
    initialValues[\\"nick-names2\\"]
  );
  const [firstName1, setFirstName1] = React.useState(
    initialValues[\\"first Name\\"]
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setFirstName(initialValues[\\"first-Name\\"]);
    setLastName(initialValues.lastName);
    setBio(initialValues.bio);
    setNicknames1(initialValues.Nicknames1);
    setCurrentNicknames1Value(undefined);
    setNickNames(initialValues[\\"nick-names2\\"]);
    setCurrentNickNamesValue(undefined);
    setFirstName1(initialValues[\\"first Name\\"]);
    setErrors({});
  };
  const [currentBioFavoritetreesValue, setCurrentBioFavoritetreesValue] =
    React.useState(undefined);
  const bioFavoritetreesRef = React.createRef();
  const [currentNicknames1Value, setCurrentNicknames1Value] =
    React.useState(undefined);
  const Nicknames1Ref = React.createRef();
  const [currentNickNamesValue, setCurrentNickNamesValue] =
    React.useState(undefined);
  const nickNamesRef = React.createRef();
  const validations = {
    \\"first-Name\\": [],
    lastName: [],
    \\"bio.favorite Quote\\": [],
    \\"bio.favorite-Animal\\": [],
    \\"bio.favorite-trees\\": [],
    Nicknames1: [],
    \\"nick-names2\\": [],
    \\"first Name\\": [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap={tokens.space.large.value}
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          \\"first-Name\\": firstName,
          lastName,
          bio,
          Nicknames1,
          \\"nick-names2\\": nickNames,
          \\"first Name\\": firstName1,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"NestedJson\\")}
    >
      <TextField
        label=\\"firstName\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": value,
              lastName,
              bio,
              Nicknames1,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            value = result?.[\\"first-Name\\"] ?? value;
          }
          if (errors[\\"first-Name\\"]?.hasError) {
            runValidationTasks(\\"first-Name\\", value);
          }
          setFirstName(value);
        }}
        onBlur={() => runValidationTasks(\\"first-Name\\", firstName)}
        errorMessage={errors[\\"first-Name\\"]?.errorMessage}
        hasError={errors[\\"first-Name\\"]?.hasError}
        {...getOverrideProps(overrides, \\"first-Name\\")}
      ></TextField>
      <TextField
        label=\\"lastName\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName: value,
              bio,
              Nicknames1,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            value = result?.lastName ?? value;
          }
          if (errors.lastName?.hasError) {
            runValidationTasks(\\"lastName\\", value);
          }
          setLastName(value);
        }}
        onBlur={() => runValidationTasks(\\"lastName\\", lastName)}
        errorMessage={errors.lastName?.errorMessage}
        hasError={errors.lastName?.hasError}
        {...getOverrideProps(overrides, \\"lastName\\")}
      ></TextField>
      <Heading
        level={3}
        children=\\"bio\\"
        {...getOverrideProps(overrides, \\"bio\\")}
      ></Heading>
      <TextField
        label=\\"favoriteQuote\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName,
              bio: { ...bio, [\\"favorite Quote\\"]: value },
              Nicknames1,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            value = result?.bio?.[\\"favorite Quote\\"] ?? value;
          }
          if (errors[\\"bio.favorite Quote\\"]?.hasError) {
            runValidationTasks(\\"bio.favorite Quote\\", value);
          }
          setBio({ ...bio, [\\"favorite Quote\\"]: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favorite Quote\\", bio[\\"favorite Quote\\"])
        }
        errorMessage={errors[\\"bio.favorite Quote\\"]?.errorMessage}
        hasError={errors[\\"bio.favorite Quote\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favorite Quote\\")}
      ></TextField>
      <TextField
        label=\\"favoriteAnimal\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName,
              bio: { ...bio, [\\"favorite-Animal\\"]: value },
              Nicknames1,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            value = result?.bio?.[\\"favorite-Animal\\"] ?? value;
          }
          if (errors[\\"bio.favorite-Animal\\"]?.hasError) {
            runValidationTasks(\\"bio.favorite-Animal\\", value);
          }
          setBio({ ...bio, [\\"favorite-Animal\\"]: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favorite-Animal\\", bio[\\"favorite-Animal\\"])
        }
        errorMessage={errors[\\"bio.favorite-Animal\\"]?.errorMessage}
        hasError={errors[\\"bio.favorite-Animal\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favorite-Animal\\")}
      ></TextField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName,
              bio: { ...bio, [\\"favorite-trees\\"]: values },
              Nicknames1,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            values = result?.bio?.[\\"favorite-trees\\"] ?? values;
          }
          setBio({ ...bio, [\\"favorite-trees\\"]: values });
          setCurrentBioFavoritetreesValue(undefined);
        }}
        currentFieldValue={currentBioFavoritetreesValue}
        label={\\"favorite trees\\"}
        items={bio.favorite - trees ?? []}
        hasError={errors?.[\\"bio.favorite-trees\\"]?.hasError}
        setFieldValue={setCurrentBioFavoritetreesValue}
        inputFieldRef={bio.favorite - treesRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"favorite trees\\"
          value={currentBioFavoritetreesValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors[\\"bio.favorite-trees\\"]?.hasError) {
              runValidationTasks(\\"bio.favorite-trees\\", value);
            }
            setCurrentBioFavoritetreesValue(value);
          }}
          onBlur={() =>
            runValidationTasks(
              \\"bio.favorite-trees\\",
              currentBioFavoritetreesValue
            )
          }
          errorMessage={errors[\\"bio.favorite-trees\\"]?.errorMessage}
          hasError={errors[\\"bio.favorite-trees\\"]?.hasError}
          ref={bioFavoritetreesRef}
          {...getOverrideProps(overrides, \\"bio.favorite-trees\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName,
              bio,
              Nicknames1: values,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            values = result?.Nicknames1 ?? values;
          }
          setNicknames1(values);
          setCurrentNicknames1Value(undefined);
        }}
        currentFieldValue={currentNicknames1Value}
        label={\\"Nick Names1\\"}
        items={Nicknames1}
        hasError={errors.Nicknames1?.hasError}
        setFieldValue={setCurrentNicknames1Value}
        inputFieldRef={Nicknames1Ref}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Nick Names1\\"
          value={currentNicknames1Value}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.Nicknames1?.hasError) {
              runValidationTasks(\\"Nicknames1\\", value);
            }
            setCurrentNicknames1Value(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"Nicknames1\\", currentNicknames1Value)
          }
          errorMessage={errors.Nicknames1?.errorMessage}
          hasError={errors.Nicknames1?.hasError}
          ref={Nicknames1Ref}
          {...getOverrideProps(overrides, \\"Nicknames1\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName,
              bio,
              Nicknames1,
              \\"nick-names2\\": values,
              \\"first Name\\": firstName1,
            };
            const result = onChange(modelFields);
            values = result?.[\\"nick-names2\\"] ?? values;
          }
          setNickNames(values);
          setCurrentNickNamesValue(undefined);
        }}
        currentFieldValue={currentNickNamesValue}
        label={\\"nick-Names2\\"}
        items={nickNames}
        hasError={errors?.[\\"nick-names2\\"]?.hasError}
        setFieldValue={setCurrentNickNamesValue}
        inputFieldRef={nickNamesRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"nick-Names2\\"
          value={currentNickNamesValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors[\\"nick-names2\\"]?.hasError) {
              runValidationTasks(\\"nick-names2\\", value);
            }
            setCurrentNickNamesValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"nick-names2\\", currentNickNamesValue)
          }
          errorMessage={errors[\\"nick-names2\\"]?.errorMessage}
          hasError={errors[\\"nick-names2\\"]?.hasError}
          ref={nickNamesRef}
          {...getOverrideProps(overrides, \\"nick-names2\\")}
        ></TextField>
      </ArrayField>
      <TextField
        label=\\"first Name1\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              \\"first-Name\\": firstName,
              lastName,
              bio,
              Nicknames1,
              \\"nick-names2\\": nickNames,
              \\"first Name\\": value,
            };
            const result = onChange(modelFields);
            value = result?.[\\"first Name\\"] ?? value;
          }
          if (errors[\\"first Name\\"]?.hasError) {
            runValidationTasks(\\"first Name\\", value);
          }
          setFirstName1(value);
        }}
        onBlur={() => runValidationTasks(\\"first Name\\", firstName1)}
        errorMessage={errors[\\"first Name\\"]?.errorMessage}
        hasError={errors[\\"first Name\\"]?.hasError}
        {...getOverrideProps(overrides, \\"first Name\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render nested json fields 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, HeadingProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type NestedJsonInputValues = {
    \\"first-Name\\"?: string;
    lastName?: string;
    Nicknames1?: string[];
    \\"nick-names2\\"?: string[];
    \\"first Name\\"?: string;
    bio?: {
        \\"favorite Quote\\"?: string;
        \\"favorite-Animal\\"?: string;
        \\"favorite-trees\\"?: string[];
    };
};
export declare type NestedJsonValidationValues = {
    \\"first-Name\\"?: ValidationFunction<string>;
    lastName?: ValidationFunction<string>;
    Nicknames1?: ValidationFunction<string>;
    \\"nick-names2\\"?: ValidationFunction<string>;
    \\"first Name\\"?: ValidationFunction<string>;
    bio?: {
        \\"favorite Quote\\"?: ValidationFunction<string>;
        \\"favorite-Animal\\"?: ValidationFunction<string>;
        \\"favorite-trees\\"?: ValidationFunction<string>;
    };
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type NestedJsonOverridesProps = {
    NestedJsonGrid?: FormProps<GridProps>;
    \\"first-Name\\"?: FormProps<TextFieldProps>;
    lastName?: FormProps<TextFieldProps>;
    bio?: FormProps<HeadingProps>;
    \\"bio.favorite Quote\\"?: FormProps<TextFieldProps>;
    \\"bio.favorite-Animal\\"?: FormProps<TextFieldProps>;
    \\"bio.favorite-trees\\"?: FormProps<TextFieldProps>;
    Nicknames1?: FormProps<TextFieldProps>;
    \\"nick-names2\\"?: FormProps<TextFieldProps>;
    \\"first Name\\"?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type NestedJsonProps = React.PropsWithChildren<{
    overrides?: NestedJsonOverridesProps | undefined | null;
} & {
    onSubmit: (fields: NestedJsonInputValues) => void;
    onChange?: (fields: NestedJsonInputValues) => NestedJsonInputValues;
    onValidate?: NestedJsonValidationValues;
} & React.CSSProperties>;
export default function NestedJson(props: NestedJsonProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render nested json fields 3`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Heading,
  Icon,
  ScrollView,
  SelectField,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function NestedJson(props) {
  const { initialData, onSubmit, onValidate, onChange, overrides, ...rest } =
    props;
  const initialValues = {
    firstName: undefined,
    \\"last-Name\\": undefined,
    lastName: [],
    bio: {},
  };
  const [firstName, setFirstName] = React.useState(initialValues.firstName);
  const [lastName, setLastName] = React.useState(initialValues[\\"last-Name\\"]);
  const [lastName1, setLastName1] = React.useState(initialValues.lastName);
  const [bio, setBio] = React.useState(initialValues.bio);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    const cleanValues = { ...initialValues, ...initialData };
    setFirstName(cleanValues.firstName);
    setLastName(cleanValues[\\"last-Name\\"]);
    setLastName1(cleanValues.lastName ?? []);
    setCurrentLastName1Value(undefined);
    setBio(cleanValues.bio);
    setErrors({});
  };
  React.useEffect(resetStateValues, [initialData]);
  React.useEffect(() => {
    if (initialData) {
      setFirstName(initialData.firstName);
      setLastName(initialData[\\"last-Name\\"]);
      setLastName1(initialData.lastName);
      setBio(initialData.bio);
    }
  }, []);
  const [currentLastName1Value, setCurrentLastName1Value] =
    React.useState(undefined);
  const lastName1Ref = React.createRef();
  const validations = {
    firstName: [],
    \\"last-Name\\": [],
    lastName: [],
    \\"bio.favoriteQuote\\": [],
    \\"bio.favoriteAnimal\\": [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          firstName,
          \\"last-Name\\": lastName,
          lastName: lastName1,
          bio,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"NestedJson\\")}
    >
      <TextField
        label=\\"firstName\\"
        defaultValue={firstName}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName: value,
              \\"last-Name\\": lastName,
              lastName: lastName1,
              bio,
            };
            const result = onChange(modelFields);
            value = result?.firstName ?? value;
          }
          if (errors.firstName?.hasError) {
            runValidationTasks(\\"firstName\\", value);
          }
          setFirstName(value);
        }}
        onBlur={() => runValidationTasks(\\"firstName\\", firstName)}
        errorMessage={errors.firstName?.errorMessage}
        hasError={errors.firstName?.hasError}
        {...getOverrideProps(overrides, \\"firstName\\")}
      ></TextField>
      <SelectField
        label=\\"last-Name\\"
        placeholder=\\"Please select an option\\"
        value={lastName}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              \\"last-Name\\": value,
              lastName: lastName1,
              bio,
            };
            const result = onChange(modelFields);
            value = result?.[\\"last-Name\\"] ?? value;
          }
          if (errors[\\"last-Name\\"]?.hasError) {
            runValidationTasks(\\"last-Name\\", value);
          }
          setLastName(value);
        }}
        onBlur={() => runValidationTasks(\\"last-Name\\", lastName)}
        errorMessage={errors[\\"last-Name\\"]?.errorMessage}
        hasError={errors[\\"last-Name\\"]?.hasError}
        {...getOverrideProps(overrides, \\"last-Name\\")}
      ></SelectField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              firstName,
              \\"last-Name\\": lastName,
              lastName: values,
              bio,
            };
            const result = onChange(modelFields);
            values = result?.lastName ?? values;
          }
          setLastName1(values);
          setCurrentLastName1Value(undefined);
        }}
        currentFieldValue={currentLastName1Value}
        label={\\"lastName\\"}
        items={lastName1}
        hasError={errors.lastName?.hasError}
        setFieldValue={setCurrentLastName1Value}
        inputFieldRef={lastName1Ref}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"lastName\\"
          value={currentLastName1Value}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.lastName?.hasError) {
              runValidationTasks(\\"lastName\\", value);
            }
            setCurrentLastName1Value(value);
          }}
          onBlur={() => runValidationTasks(\\"lastName\\", currentLastName1Value)}
          errorMessage={errors.lastName?.errorMessage}
          hasError={errors.lastName?.hasError}
          ref={lastName1Ref}
          {...getOverrideProps(overrides, \\"lastName\\")}
        ></TextField>
      </ArrayField>
      <Heading
        level={3}
        children=\\"bio\\"
        {...getOverrideProps(overrides, \\"bio\\")}
      ></Heading>
      <TextField
        label=\\"favoriteQuote\\"
        defaultValue={bio.favoriteQuote}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              \\"last-Name\\": lastName,
              lastName: lastName1,
              bio: { ...bio, favoriteQuote: value },
            };
            const result = onChange(modelFields);
            value = result?.bio?.favoriteQuote ?? value;
          }
          if (errors[\\"bio.favoriteQuote\\"]?.hasError) {
            runValidationTasks(\\"bio.favoriteQuote\\", value);
          }
          setBio({ ...bio, favoriteQuote: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favoriteQuote\\", bio[\\"favoriteQuote\\"])
        }
        errorMessage={errors[\\"bio.favoriteQuote\\"]?.errorMessage}
        hasError={errors[\\"bio.favoriteQuote\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favoriteQuote\\")}
      ></TextField>
      <TextField
        label=\\"favoriteAnimal\\"
        defaultValue={bio.favoriteAnimal}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              \\"last-Name\\": lastName,
              lastName: lastName1,
              bio: { ...bio, favoriteAnimal: value },
            };
            const result = onChange(modelFields);
            value = result?.bio?.favoriteAnimal ?? value;
          }
          if (errors[\\"bio.favoriteAnimal\\"]?.hasError) {
            runValidationTasks(\\"bio.favoriteAnimal\\", value);
          }
          setBio({ ...bio, favoriteAnimal: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favoriteAnimal\\", bio[\\"favoriteAnimal\\"])
        }
        errorMessage={errors[\\"bio.favoriteAnimal\\"]?.errorMessage}
        hasError={errors[\\"bio.favoriteAnimal\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favoriteAnimal\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Reset\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ResetButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render nested json fields 4`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, HeadingProps, SelectFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type NestedJsonInputValues = {
    firstName?: string;
    \\"last-Name\\"?: string;
    lastName?: string[];
    bio?: {
        favoriteQuote?: string;
        favoriteAnimal?: string;
    };
};
export declare type NestedJsonValidationValues = {
    firstName?: ValidationFunction<string>;
    \\"last-Name\\"?: ValidationFunction<string>;
    lastName?: ValidationFunction<string>;
    bio?: {
        favoriteQuote?: ValidationFunction<string>;
        favoriteAnimal?: ValidationFunction<string>;
    };
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type NestedJsonOverridesProps = {
    NestedJsonGrid?: FormProps<GridProps>;
    firstName?: FormProps<TextFieldProps>;
    \\"last-Name\\"?: FormProps<SelectFieldProps>;
    lastName?: FormProps<TextFieldProps>;
    bio?: FormProps<HeadingProps>;
    \\"bio.favoriteQuote\\"?: FormProps<TextFieldProps>;
    \\"bio.favoriteAnimal\\"?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type NestedJsonProps = React.PropsWithChildren<{
    overrides?: NestedJsonOverridesProps | undefined | null;
} & {
    initialData?: NestedJsonInputValues;
    onSubmit: (fields: NestedJsonInputValues) => void;
    onChange?: (fields: NestedJsonInputValues) => NestedJsonInputValues;
    onValidate?: NestedJsonValidationValues;
} & React.CSSProperties>;
export default function NestedJson(props: NestedJsonProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render sectional elements 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Divider,
  Flex,
  Grid,
  Heading,
  Text,
  TextField,
} from \\"@aws-amplify/ui-react\\";
export default function CustomWithSectionalElements(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const initialValues = {
    name: undefined,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setErrors({});
  };
  const validations = {
    name: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomWithSectionalElements\\")}
    >
      <Heading
        level={2}
        children=\\"Create a Post\\"
        {...getOverrideProps(overrides, \\"myHeading\\")}
      ></Heading>
      <TextField
        label=\\"Label\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <Text
        children=\\"Did you put your name above?\\"
        {...getOverrideProps(overrides, \\"myText\\")}
      ></Text>
      <Divider
        orientation=\\"horizontal\\"
        {...getOverrideProps(overrides, \\"myDivider\\")}
      ></Divider>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests custom form tests should render sectional elements 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { DividerProps, GridProps, HeadingProps, TextFieldProps, TextProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type CustomWithSectionalElementsInputValues = {
    name?: string;
};
export declare type CustomWithSectionalElementsValidationValues = {
    name?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomWithSectionalElementsOverridesProps = {
    CustomWithSectionalElementsGrid?: FormProps<GridProps>;
    myHeading?: FormProps<HeadingProps>;
    name?: FormProps<TextFieldProps>;
    myText?: FormProps<TextProps>;
    myDivider?: FormProps<DividerProps>;
} & EscapeHatchProps;
export declare type CustomWithSectionalElementsProps = React.PropsWithChildren<{
    overrides?: CustomWithSectionalElementsOverridesProps | undefined | null;
} & {
    onSubmit: (fields: CustomWithSectionalElementsInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomWithSectionalElementsInputValues) => CustomWithSectionalElementsInputValues;
    onValidate?: CustomWithSectionalElementsValidationValues;
} & React.CSSProperties>;
export default function CustomWithSectionalElements(props: CustomWithSectionalElementsProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  TextAreaField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
export default function MyPostForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    caption: undefined,
    username: undefined,
    post_url: undefined,
    metadata: undefined,
    profile_url: undefined,
  };
  const [caption, setCaption] = React.useState(initialValues.caption);
  const [username, setUsername] = React.useState(initialValues.username);
  const [post_url, setPost_url] = React.useState(initialValues.post_url);
  const [metadata, setMetadata] = React.useState(
    initialValues.metadata ? JSON.stringify(initialValues.metadata) : undefined
  );
  const [profile_url, setProfile_url] = React.useState(
    initialValues.profile_url
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setCaption(initialValues.caption);
    setUsername(initialValues.username);
    setPost_url(initialValues.post_url);
    setMetadata(initialValues.metadata);
    setProfile_url(initialValues.profile_url);
    setErrors({});
  };
  const validations = {
    caption: [],
    username: [],
    post_url: [{ type: \\"URL\\" }],
    metadata: [{ type: \\"JSON\\" }],
    profile_url: [{ type: \\"URL\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          caption,
          username,
          post_url: post_url || undefined,
          metadata,
          profile_url: profile_url || undefined,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Post(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyPostForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextField
        label=\\"Caption\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption: value,
              username,
              post_url,
              metadata,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.caption ?? value;
          }
          if (errors.caption?.hasError) {
            runValidationTasks(\\"caption\\", value);
          }
          setCaption(value);
        }}
        onBlur={() => runValidationTasks(\\"caption\\", caption)}
        errorMessage={errors.caption?.errorMessage}
        hasError={errors.caption?.hasError}
        {...getOverrideProps(overrides, \\"caption\\")}
      ></TextField>
      <TextField
        label=\\"Username\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username: value,
              post_url,
              metadata,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.username ?? value;
          }
          if (errors.username?.hasError) {
            runValidationTasks(\\"username\\", value);
          }
          setUsername(value);
        }}
        onBlur={() => runValidationTasks(\\"username\\", username)}
        errorMessage={errors.username?.errorMessage}
        hasError={errors.username?.hasError}
        {...getOverrideProps(overrides, \\"username\\")}
      ></TextField>
      <TextField
        label=\\"Post url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username,
              post_url: value,
              metadata,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <TextAreaField
        label=\\"Metadata\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username,
              post_url,
              metadata: value,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.metadata ?? value;
          }
          if (errors.metadata?.hasError) {
            runValidationTasks(\\"metadata\\", value);
          }
          setMetadata(value);
        }}
        onBlur={() => runValidationTasks(\\"metadata\\", metadata)}
        errorMessage={errors.metadata?.errorMessage}
        hasError={errors.metadata?.hasError}
        {...getOverrideProps(overrides, \\"metadata\\")}
      ></TextAreaField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username,
              post_url,
              metadata,
              profile_url: value,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextAreaFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyPostFormInputValues = {
    caption?: string;
    username?: string;
    post_url?: string;
    metadata?: string;
    profile_url?: string;
};
export declare type MyPostFormValidationValues = {
    caption?: ValidationFunction<string>;
    username?: ValidationFunction<string>;
    post_url?: ValidationFunction<string>;
    metadata?: ValidationFunction<string>;
    profile_url?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyPostFormOverridesProps = {
    MyPostFormGrid?: FormProps<GridProps>;
    caption?: FormProps<TextFieldProps>;
    username?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
    metadata?: FormProps<TextAreaFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type MyPostFormProps = React.PropsWithChildren<{
    overrides?: MyPostFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onSuccess?: (fields: MyPostFormInputValues) => void;
    onError?: (fields: MyPostFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onValidate?: MyPostFormValidationValues;
} & React.CSSProperties>;
export default function MyPostForm(props: MyPostFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with belongsTo relationship 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Member, Team as Team0 } from \\"../models\\";
import {
  getOverrideProps,
  useDataStoreBinding,
} from \\"@aws-amplify/ui-react/internal\\";
import {
  Autocomplete,
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function MyMemberForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    name: undefined,
    Team: undefined,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [Team, setTeam] = React.useState(initialValues.Team);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setTeam(initialValues.Team);
    setCurrentTeamValue(undefined);
    setCurrentTeamDisplayValue(\\"\\");
    setErrors({});
  };
  const [currentTeamDisplayValue, setCurrentTeamDisplayValue] =
    React.useState(\\"\\");
  const [currentTeamValue, setCurrentTeamValue] = React.useState(undefined);
  const TeamRef = React.createRef();
  const teamRecords = useDataStoreBinding({
    type: \\"collection\\",
    model: Team0,
  }).items;
  const getDisplayValue = {
    Team: (record) => record?.name,
  };
  const validations = {
    name: [],
    Team: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          name,
          Team,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(
                    fieldName,
                    item,
                    getDisplayValue[fieldName]
                  )
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(
                fieldName,
                modelFields[fieldName],
                getDisplayValue[fieldName]
              )
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Member(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyMemberForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextField
        label=\\"Name\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              Team,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <ArrayField
        lengthLimit={1}
        onChange={async (items) => {
          let value = items[0];
          if (onChange) {
            const modelFields = {
              name,
              Team: value,
            };
            const result = onChange(modelFields);
            value = result?.Team ?? value;
          }
          setTeam(value);
          setCurrentTeamValue(undefined);
          setCurrentTeamDisplayValue(\\"\\");
        }}
        currentFieldValue={currentTeamValue}
        label={\\"Team Label\\"}
        items={Team ? [Team] : []}
        hasError={errors.Team?.hasError}
        getBadgeText={getDisplayValue.Team}
        setFieldValue={currentTeamDisplayValue}
        inputFieldRef={TeamRef}
        defaultFieldValue={undefined}
      >
        <Autocomplete
          label=\\"Team Label\\"
          isRequired={false}
          isReadOnly={false}
          value={currentTeamDisplayValue}
          options={teamRecords.map((r) => ({
            id: r.id,
            label: getDisplayValue.Team?.(r) ?? r.id,
          }))}
          onSelect={({ id, label }) => {
            setCurrentTeamValue(teamRecords.find((r) => r.id === id));
            setCurrentTeamDisplayValue(label);
          }}
          onClear={() => {
            setCurrentTeamDisplayValue(\\"\\");
          }}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.Team?.hasError) {
              runValidationTasks(\\"Team\\", value);
            }
            setCurrentTeamDisplayValue(value);
            setCurrentTeamValue(undefined);
          }}
          onBlur={() => runValidationTasks(\\"Team\\", Team)}
          errorMessage={errors.Team?.errorMessage}
          hasError={errors.Team?.hasError}
          ref={TeamRef}
          {...getOverrideProps(overrides, \\"Team\\")}
        ></Autocomplete>
      </ArrayField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with belongsTo relationship 2`] = `
"import * as React from \\"react\\";
import { Team as Team0 } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { AutocompleteProps, GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyMemberFormInputValues = {
    name?: string;
    Team?: Team0;
};
export declare type MyMemberFormValidationValues = {
    name?: ValidationFunction<string>;
    Team?: ValidationFunction<Team0>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyMemberFormOverridesProps = {
    MyMemberFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    Team?: FormProps<AutocompleteProps>;
} & EscapeHatchProps;
export declare type MyMemberFormProps = React.PropsWithChildren<{
    overrides?: MyMemberFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: MyMemberFormInputValues) => MyMemberFormInputValues;
    onSuccess?: (fields: MyMemberFormInputValues) => void;
    onError?: (fields: MyMemberFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyMemberFormInputValues) => MyMemberFormInputValues;
    onValidate?: MyMemberFormValidationValues;
} & React.CSSProperties>;
export default function MyMemberForm(props: MyMemberFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with hasOne relationship 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Book, Author } from \\"../models\\";
import {
  getOverrideProps,
  useDataStoreBinding,
} from \\"@aws-amplify/ui-react/internal\\";
import {
  Autocomplete,
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function BookCreateForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    name: undefined,
    primaryAuthor: undefined,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [primaryAuthor, setPrimaryAuthor] = React.useState(
    initialValues.primaryAuthor
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setPrimaryAuthor(initialValues.primaryAuthor);
    setCurrentPrimaryAuthorValue(undefined);
    setCurrentPrimaryAuthorDisplayValue(\\"\\");
    setErrors({});
  };
  const [
    currentPrimaryAuthorDisplayValue,
    setCurrentPrimaryAuthorDisplayValue,
  ] = React.useState(\\"\\");
  const [currentPrimaryAuthorValue, setCurrentPrimaryAuthorValue] =
    React.useState(undefined);
  const primaryAuthorRef = React.createRef();
  const authorRecords = useDataStoreBinding({
    type: \\"collection\\",
    model: Author,
  }).items;
  const getDisplayValue = {
    primaryAuthor: (record) => record?.name,
  };
  const validations = {
    name: [],
    primaryAuthor: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          name,
          primaryAuthor,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(
                    fieldName,
                    item,
                    getDisplayValue[fieldName]
                  )
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(
                fieldName,
                modelFields[fieldName],
                getDisplayValue[fieldName]
              )
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Book(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"BookCreateForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextField
        label=\\"Name\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              primaryAuthor,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <ArrayField
        lengthLimit={1}
        onChange={async (items) => {
          let value = items[0];
          if (onChange) {
            const modelFields = {
              name,
              primaryAuthor: value,
            };
            const result = onChange(modelFields);
            value = result?.primaryAuthor ?? value;
          }
          setPrimaryAuthor(value);
          setCurrentPrimaryAuthorValue(undefined);
          setCurrentPrimaryAuthorDisplayValue(\\"\\");
        }}
        currentFieldValue={currentPrimaryAuthorValue}
        label={\\"Primary author\\"}
        items={primaryAuthor ? [primaryAuthor] : []}
        hasError={errors.primaryAuthor?.hasError}
        getBadgeText={getDisplayValue.primaryAuthor}
        setFieldValue={setCurrentPrimaryAuthorDisplayValue}
        inputFieldRef={primaryAuthorRef}
        defaultFieldValue={\\"\\"}
      >
        <Autocomplete
          label=\\"Primary author\\"
          isRequired={false}
          isReadOnly={false}
          value={currentPrimaryAuthorDisplayValue}
          options={authorRecords.map((r) => ({
            id: r.id,
            label: getDisplayValue.primaryAuthor?.(r) ?? r.id,
          }))}
          onSelect={({ id, label }) => {
            setCurrentPrimaryAuthorValue(
              authorRecords.find((r) => r.id === id)
            );
            setCurrentPrimaryAuthorDisplayValue(label);
          }}
          onClear={() => {
            setCurrentPrimaryAuthorDisplayValue(\\"\\");
          }}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.primaryAuthor?.hasError) {
              runValidationTasks(\\"primaryAuthor\\", value);
            }
            setCurrentPrimaryAuthorDisplayValue(value);
            setCurrentPrimaryAuthorValue(undefined);
          }}
          onBlur={() => runValidationTasks(\\"primaryAuthor\\", primaryAuthor)}
          errorMessage={errors.primaryAuthor?.errorMessage}
          hasError={errors.primaryAuthor?.hasError}
          ref={primaryAuthorRef}
          {...getOverrideProps(overrides, \\"primaryAuthor\\")}
        ></Autocomplete>
      </ArrayField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with hasOne relationship 2`] = `
"import * as React from \\"react\\";
import { Author } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { AutocompleteProps, GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type BookCreateFormInputValues = {
    name?: string;
    primaryAuthor?: Author;
};
export declare type BookCreateFormValidationValues = {
    name?: ValidationFunction<string>;
    primaryAuthor?: ValidationFunction<Author>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type BookCreateFormOverridesProps = {
    BookCreateFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    primaryAuthor?: FormProps<AutocompleteProps>;
} & EscapeHatchProps;
export declare type BookCreateFormProps = React.PropsWithChildren<{
    overrides?: BookCreateFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: BookCreateFormInputValues) => BookCreateFormInputValues;
    onSuccess?: (fields: BookCreateFormInputValues) => void;
    onError?: (fields: BookCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: BookCreateFormInputValues) => BookCreateFormInputValues;
    onValidate?: BookCreateFormValidationValues;
} & React.CSSProperties>;
export default function BookCreateForm(props: BookCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with manyToMany relationship 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Tag, Post, TagPost } from \\"../models\\";
import {
  getOverrideProps,
  useDataStoreBinding,
} from \\"@aws-amplify/ui-react/internal\\";
import {
  Autocomplete,
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function TagCreateForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    label: undefined,
    Posts: [],
  };
  const [label, setLabel] = React.useState(initialValues.label);
  const [Posts, setPosts] = React.useState(initialValues.Posts);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setLabel(initialValues.label);
    setPosts(initialValues.Posts);
    setCurrentPostsValue(undefined);
    setCurrentPostsDisplayValue(\\"\\");
    setErrors({});
  };
  const [currentPostsDisplayValue, setCurrentPostsDisplayValue] =
    React.useState(\\"\\");
  const [currentPostsValue, setCurrentPostsValue] = React.useState(undefined);
  const PostsRef = React.createRef();
  const postRecords = useDataStoreBinding({
    type: \\"collection\\",
    model: Post,
  }).items;
  const getDisplayValue = {
    Posts: (record) => record?.title,
  };
  const validations = {
    label: [],
    Posts: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          label,
          Posts,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(
                    fieldName,
                    item,
                    getDisplayValue[fieldName]
                  )
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(
                fieldName,
                modelFields[fieldName],
                getDisplayValue[fieldName]
              )
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          const tag = await DataStore.save(new Tag(modelFields));
          await Promise.all(
            Posts.reduce((promises, post) => {
              promises.push(
                DataStore.save(
                  new TagPost({
                    tag,
                    post,
                  })
                )
              );
              return promises;
            }, [])
          );
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"TagCreateForm\\")}
    >
      <TextField
        label=\\"Label\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              label: value,
              Posts,
            };
            const result = onChange(modelFields);
            value = result?.label ?? value;
          }
          if (errors.label?.hasError) {
            runValidationTasks(\\"label\\", value);
          }
          setLabel(value);
        }}
        onBlur={() => runValidationTasks(\\"label\\", label)}
        errorMessage={errors.label?.errorMessage}
        hasError={errors.label?.hasError}
        {...getOverrideProps(overrides, \\"label\\")}
      ></TextField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              label,
              Posts: values,
            };
            const result = onChange(modelFields);
            values = result?.Posts ?? values;
          }
          setPosts(values);
          setCurrentPostsValue(undefined);
          setCurrentPostsDisplayValue(\\"\\");
        }}
        currentFieldValue={currentPostsValue}
        label={\\"Posts\\"}
        items={Posts}
        hasError={errors.Posts?.hasError}
        getBadgeText={getDisplayValue.Posts}
        setFieldValue={setCurrentPostsDisplayValue}
        inputFieldRef={PostsRef}
        defaultFieldValue={\\"\\"}
      >
        <Autocomplete
          label=\\"Posts\\"
          isRequired={false}
          isReadOnly={false}
          value={currentPostsDisplayValue}
          options={postRecords.map((r) => ({
            id: r.id,
            label: getDisplayValue.Posts?.(r) ?? r.id,
          }))}
          onSelect={({ id, label }) => {
            setCurrentPostsValue(postRecords.find((r) => r.id === id));
            setCurrentPostsDisplayValue(label);
          }}
          onClear={() => {
            setCurrentPostsDisplayValue(\\"\\");
          }}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.Posts?.hasError) {
              runValidationTasks(\\"Posts\\", value);
            }
            setCurrentPostsDisplayValue(value);
            setCurrentPostsValue(undefined);
          }}
          onBlur={() => runValidationTasks(\\"Posts\\", currentPostsValue)}
          errorMessage={errors.Posts?.errorMessage}
          hasError={errors.Posts?.hasError}
          ref={PostsRef}
          {...getOverrideProps(overrides, \\"Posts\\")}
        ></Autocomplete>
      </ArrayField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with manyToMany relationship 2`] = `
"import * as React from \\"react\\";
import { Post } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { AutocompleteProps, GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type TagCreateFormInputValues = {
    label?: string;
    Posts?: Post[];
};
export declare type TagCreateFormValidationValues = {
    label?: ValidationFunction<string>;
    Posts?: ValidationFunction<Post>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type TagCreateFormOverridesProps = {
    TagCreateFormGrid?: FormProps<GridProps>;
    label?: FormProps<TextFieldProps>;
    Posts?: FormProps<AutocompleteProps>;
} & EscapeHatchProps;
export declare type TagCreateFormProps = React.PropsWithChildren<{
    overrides?: TagCreateFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: TagCreateFormInputValues) => TagCreateFormInputValues;
    onSuccess?: (fields: TagCreateFormInputValues) => void;
    onError?: (fields: TagCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: TagCreateFormInputValues) => TagCreateFormInputValues;
    onValidate?: TagCreateFormValidationValues;
} & React.CSSProperties>;
export default function TagCreateForm(props: TagCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with multiple hasOne relationships 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Book, Author, Title } from \\"../models\\";
import {
  getOverrideProps,
  useDataStoreBinding,
} from \\"@aws-amplify/ui-react/internal\\";
import {
  Autocomplete,
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function BookCreateForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    name: undefined,
    primaryAuthor: undefined,
    primaryTitle: undefined,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [primaryAuthor, setPrimaryAuthor] = React.useState(
    initialValues.primaryAuthor
  );
  const [primaryTitle, setPrimaryTitle] = React.useState(
    initialValues.primaryTitle
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setPrimaryAuthor(initialValues.primaryAuthor);
    setCurrentPrimaryAuthorValue(undefined);
    setCurrentPrimaryAuthorDisplayValue(\\"\\");
    setPrimaryTitle(initialValues.primaryTitle);
    setCurrentPrimaryTitleValue(undefined);
    setCurrentPrimaryTitleDisplayValue(\\"\\");
    setErrors({});
  };
  const [
    currentPrimaryAuthorDisplayValue,
    setCurrentPrimaryAuthorDisplayValue,
  ] = React.useState(\\"\\");
  const [currentPrimaryAuthorValue, setCurrentPrimaryAuthorValue] =
    React.useState(undefined);
  const primaryAuthorRef = React.createRef();
  const [currentPrimaryTitleDisplayValue, setCurrentPrimaryTitleDisplayValue] =
    React.useState(\\"\\");
  const [currentPrimaryTitleValue, setCurrentPrimaryTitleValue] =
    React.useState(undefined);
  const primaryTitleRef = React.createRef();
  const authorRecords = useDataStoreBinding({
    type: \\"collection\\",
    model: Author,
  }).items;
  const titleRecords = useDataStoreBinding({
    type: \\"collection\\",
    model: Title,
  }).items;
  const getDisplayValue = {
    primaryAuthor: (record) => record?.name,
    primaryTitle: (record) => record?.name,
  };
  const validations = {
    name: [],
    primaryAuthor: [],
    primaryTitle: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          name,
          primaryAuthor,
          primaryTitle,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(
                    fieldName,
                    item,
                    getDisplayValue[fieldName]
                  )
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(
                fieldName,
                modelFields[fieldName],
                getDisplayValue[fieldName]
              )
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Book(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"BookCreateForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextField
        label=\\"Name\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              primaryAuthor,
              primaryTitle,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <ArrayField
        lengthLimit={1}
        onChange={async (items) => {
          let value = items[0];
          if (onChange) {
            const modelFields = {
              name,
              primaryAuthor: value,
              primaryTitle,
            };
            const result = onChange(modelFields);
            value = result?.primaryAuthor ?? value;
          }
          setPrimaryAuthor(value);
          setCurrentPrimaryAuthorValue(undefined);
          setCurrentPrimaryAuthorDisplayValue(\\"\\");
        }}
        currentFieldValue={currentPrimaryAuthorValue}
        label={\\"Primary author\\"}
        items={primaryAuthor ? [primaryAuthor] : []}
        hasError={errors.primaryAuthor?.hasError}
        getBadgeText={getDisplayValue.primaryAuthor}
        setFieldValue={setCurrentPrimaryAuthorDisplayValue}
        inputFieldRef={primaryAuthorRef}
        defaultFieldValue={\\"\\"}
      >
        <Autocomplete
          label=\\"Primary author\\"
          isRequired={false}
          isReadOnly={false}
          value={currentPrimaryAuthorDisplayValue}
          options={authorRecords.map((r) => ({
            id: r.id,
            label: getDisplayValue.primaryAuthor?.(r) ?? r.id,
          }))}
          onSelect={({ id, label }) => {
            setCurrentPrimaryAuthorValue(
              authorRecords.find((r) => r.id === id)
            );
            setCurrentPrimaryAuthorDisplayValue(label);
          }}
          onClear={() => {
            setCurrentPrimaryAuthorDisplayValue(\\"\\");
          }}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.primaryAuthor?.hasError) {
              runValidationTasks(\\"primaryAuthor\\", value);
            }
            setCurrentPrimaryAuthorDisplayValue(value);
            setCurrentPrimaryAuthorValue(undefined);
          }}
          onBlur={() => runValidationTasks(\\"primaryAuthor\\", primaryAuthor)}
          errorMessage={errors.primaryAuthor?.errorMessage}
          hasError={errors.primaryAuthor?.hasError}
          ref={primaryAuthorRef}
          {...getOverrideProps(overrides, \\"primaryAuthor\\")}
        ></Autocomplete>
      </ArrayField>
      <ArrayField
        lengthLimit={1}
        onChange={async (items) => {
          let value = items[0];
          if (onChange) {
            const modelFields = {
              name,
              primaryAuthor,
              primaryTitle: value,
            };
            const result = onChange(modelFields);
            value = result?.primaryTitle ?? value;
          }
          setPrimaryTitle(value);
          setCurrentPrimaryTitleValue(undefined);
          setCurrentPrimaryTitleDisplayValue(\\"\\");
        }}
        currentFieldValue={currentPrimaryTitleValue}
        label={\\"Primary title\\"}
        items={primaryTitle ? [primaryTitle] : []}
        hasError={errors.primaryTitle?.hasError}
        getBadgeText={getDisplayValue.primaryTitle}
        setFieldValue={setCurrentPrimaryTitleDisplayValue}
        inputFieldRef={primaryTitleRef}
        defaultFieldValue={\\"\\"}
      >
        <Autocomplete
          label=\\"Primary title\\"
          isRequired={false}
          isReadOnly={false}
          value={currentPrimaryTitleDisplayValue}
          options={titleRecords.map((r) => ({
            id: r.id,
            label: getDisplayValue.primaryTitle?.(r) ?? r.id,
          }))}
          onSelect={({ id, label }) => {
            setCurrentPrimaryTitleValue(titleRecords.find((r) => r.id === id));
            setCurrentPrimaryTitleDisplayValue(label);
          }}
          onClear={() => {
            setCurrentPrimaryTitleDisplayValue(\\"\\");
          }}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.primaryTitle?.hasError) {
              runValidationTasks(\\"primaryTitle\\", value);
            }
            setCurrentPrimaryTitleDisplayValue(value);
            setCurrentPrimaryTitleValue(undefined);
          }}
          onBlur={() => runValidationTasks(\\"primaryTitle\\", primaryTitle)}
          errorMessage={errors.primaryTitle?.errorMessage}
          hasError={errors.primaryTitle?.hasError}
          ref={primaryTitleRef}
          {...getOverrideProps(overrides, \\"primaryTitle\\")}
        ></Autocomplete>
      </ArrayField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form with multiple hasOne relationships 2`] = `
"import * as React from \\"react\\";
import { Author, Title } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { AutocompleteProps, GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type BookCreateFormInputValues = {
    name?: string;
    primaryAuthor?: Author;
    primaryTitle?: Title;
};
export declare type BookCreateFormValidationValues = {
    name?: ValidationFunction<string>;
    primaryAuthor?: ValidationFunction<Author>;
    primaryTitle?: ValidationFunction<Title>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type BookCreateFormOverridesProps = {
    BookCreateFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    primaryAuthor?: FormProps<AutocompleteProps>;
    primaryTitle?: FormProps<AutocompleteProps>;
} & EscapeHatchProps;
export declare type BookCreateFormProps = React.PropsWithChildren<{
    overrides?: BookCreateFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: BookCreateFormInputValues) => BookCreateFormInputValues;
    onSuccess?: (fields: BookCreateFormInputValues) => void;
    onError?: (fields: BookCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: BookCreateFormInputValues) => BookCreateFormInputValues;
    onValidate?: BookCreateFormValidationValues;
} & React.CSSProperties>;
export default function BookCreateForm(props: BookCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a update form 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  TextAreaField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
export default function MyPostForm(props) {
  const {
    id,
    post,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    TextAreaFieldbbd63464: undefined,
    caption: undefined,
    username: undefined,
    profile_url: undefined,
    post_url: undefined,
    metadata: undefined,
  };
  const [TextAreaFieldbbd63464, setTextAreaFieldbbd63464] = React.useState(
    initialValues.TextAreaFieldbbd63464
  );
  const [caption, setCaption] = React.useState(initialValues.caption);
  const [username, setUsername] = React.useState(initialValues.username);
  const [profile_url, setProfile_url] = React.useState(
    initialValues.profile_url
  );
  const [post_url, setPost_url] = React.useState(initialValues.post_url);
  const [metadata, setMetadata] = React.useState(
    initialValues.metadata ? JSON.stringify(initialValues.metadata) : undefined
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    const cleanValues = { ...initialValues, ...postRecord };
    setTextAreaFieldbbd63464(cleanValues.TextAreaFieldbbd63464);
    setCaption(cleanValues.caption);
    setUsername(cleanValues.username);
    setProfile_url(cleanValues.profile_url);
    setPost_url(cleanValues.post_url);
    setMetadata(
      typeof cleanValues.metadata === \\"string\\"
        ? cleanValues.metadata
        : JSON.stringify(cleanValues.metadata)
    );
    setErrors({});
  };
  const [postRecord, setPostRecord] = React.useState(post);
  React.useEffect(() => {
    const queryData = async () => {
      const record = id ? await DataStore.query(Post, id) : post;
      setPostRecord(record);
    };
    queryData();
  }, [id, post]);
  React.useEffect(resetStateValues, [postRecord]);
  const validations = {
    TextAreaFieldbbd63464: [],
    caption: [],
    username: [],
    profile_url: [{ type: \\"URL\\" }],
    post_url: [{ type: \\"URL\\" }],
    metadata: [{ type: \\"JSON\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          TextAreaFieldbbd63464,
          caption,
          username,
          profile_url: profile_url || undefined,
          post_url: post_url || undefined,
          metadata,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          const original = await DataStore.query(Post, id);
          await DataStore.save(
            Post.copyOf(original, (updated) => {
              Object.assign(updated, modelFields);
            })
          );
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyPostForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Reset\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ResetButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextAreaField
        label=\\"Label\\"
        defaultValue={TextAreaFieldbbd63464}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464: value,
              caption,
              username,
              profile_url,
              post_url,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.TextAreaFieldbbd63464 ?? value;
          }
          if (errors.TextAreaFieldbbd63464?.hasError) {
            runValidationTasks(\\"TextAreaFieldbbd63464\\", value);
          }
          setTextAreaFieldbbd63464(value);
        }}
        onBlur={() =>
          runValidationTasks(\\"TextAreaFieldbbd63464\\", TextAreaFieldbbd63464)
        }
        errorMessage={errors.TextAreaFieldbbd63464?.errorMessage}
        hasError={errors.TextAreaFieldbbd63464?.hasError}
        {...getOverrideProps(overrides, \\"TextAreaFieldbbd63464\\")}
      ></TextAreaField>
      <TextField
        label=\\"Caption\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={caption}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption: value,
              username,
              profile_url,
              post_url,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.caption ?? value;
          }
          if (errors.caption?.hasError) {
            runValidationTasks(\\"caption\\", value);
          }
          setCaption(value);
        }}
        onBlur={() => runValidationTasks(\\"caption\\", caption)}
        errorMessage={errors.caption?.errorMessage}
        hasError={errors.caption?.hasError}
        {...getOverrideProps(overrides, \\"caption\\")}
      ></TextField>
      <TextField
        label=\\"Username\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={username}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username: value,
              profile_url,
              post_url,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.username ?? value;
          }
          if (errors.username?.hasError) {
            runValidationTasks(\\"username\\", value);
          }
          setUsername(value);
        }}
        onBlur={() => runValidationTasks(\\"username\\", username)}
        errorMessage={errors.username?.errorMessage}
        hasError={errors.username?.hasError}
        {...getOverrideProps(overrides, \\"username\\")}
      ></TextField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={profile_url}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username,
              profile_url: value,
              post_url,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
      <TextField
        label=\\"Post url\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={post_url}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username,
              profile_url,
              post_url: value,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <TextAreaField
        label=\\"Metadata\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={metadata}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username,
              profile_url,
              post_url,
              metadata: value,
            };
            const result = onChange(modelFields);
            value = result?.metadata ?? value;
          }
          if (errors.metadata?.hasError) {
            runValidationTasks(\\"metadata\\", value);
          }
          setMetadata(value);
        }}
        onBlur={() => runValidationTasks(\\"metadata\\", metadata)}
        errorMessage={errors.metadata?.errorMessage}
        hasError={errors.metadata?.hasError}
        {...getOverrideProps(overrides, \\"metadata\\")}
      ></TextAreaField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Reset\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ResetButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a update form 2`] = `
"import * as React from \\"react\\";
import { Post } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextAreaFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyPostFormInputValues = {
    TextAreaFieldbbd63464?: string;
    caption?: string;
    username?: string;
    profile_url?: string;
    post_url?: string;
    metadata?: string;
};
export declare type MyPostFormValidationValues = {
    TextAreaFieldbbd63464?: ValidationFunction<string>;
    caption?: ValidationFunction<string>;
    username?: ValidationFunction<string>;
    profile_url?: ValidationFunction<string>;
    post_url?: ValidationFunction<string>;
    metadata?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyPostFormOverridesProps = {
    MyPostFormGrid?: FormProps<GridProps>;
    TextAreaFieldbbd63464?: FormProps<TextAreaFieldProps>;
    caption?: FormProps<TextFieldProps>;
    username?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
    metadata?: FormProps<TextAreaFieldProps>;
} & EscapeHatchProps;
export declare type MyPostFormProps = React.PropsWithChildren<{
    overrides?: MyPostFormOverridesProps | undefined | null;
} & {
    id?: string;
    post?: Post;
    onSubmit?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onSuccess?: (fields: MyPostFormInputValues) => void;
    onError?: (fields: MyPostFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onValidate?: MyPostFormValidationValues;
} & React.CSSProperties>;
export default function MyPostForm(props: MyPostFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a create form with colliding model name 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Flex as Flex0 } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function MyFlexUpdateForm(props) {
  const {
    id,
    flex,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    username: undefined,
    caption: undefined,
    Customtags: [],
    tags: [],
    profile_url: undefined,
  };
  const [username, setUsername] = React.useState(initialValues.username);
  const [caption, setCaption] = React.useState(initialValues.caption);
  const [Customtags, setCustomtags] = React.useState(initialValues.Customtags);
  const [tags, setTags] = React.useState(initialValues.tags);
  const [profile_url, setProfile_url] = React.useState(
    initialValues.profile_url
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    const cleanValues = { ...initialValues, ...flexRecord };
    setUsername(cleanValues.username);
    setCaption(cleanValues.caption);
    setCustomtags(cleanValues.Customtags ?? []);
    setCurrentCustomtagsValue(undefined);
    setTags(cleanValues.tags ?? []);
    setCurrentTagsValue(undefined);
    setProfile_url(cleanValues.profile_url);
    setErrors({});
  };
  const [flexRecord, setFlexRecord] = React.useState(flex);
  React.useEffect(() => {
    const queryData = async () => {
      const record = id ? await DataStore.query(Flex0, id) : flex0;
      setFlexRecord(record);
    };
    queryData();
  }, [id, flex]);
  React.useEffect(resetStateValues, [flexRecord]);
  const [currentCustomtagsValue, setCurrentCustomtagsValue] =
    React.useState(undefined);
  const CustomtagsRef = React.createRef();
  const [currentTagsValue, setCurrentTagsValue] = React.useState(undefined);
  const tagsRef = React.createRef();
  const validations = {
    username: [
      {
        type: \\"GreaterThanChar\\",
        numValues: [2],
        validationMessage: \\"needs to be of length 2\\",
      },
    ],
    caption: [],
    Customtags: [],
    tags: [],
    profile_url: [{ type: \\"URL\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          username,
          caption,
          Customtags,
          tags,
          profile_url: profile_url || undefined,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          const original = await DataStore.query(Flex0, id);
          await DataStore.save(
            Flex0.copyOf(original, (updated) => {
              Object.assign(updated, modelFields);
            })
          );
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyFlexUpdateForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Reset\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ResetButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <Grid
        columnGap=\\"inherit\\"
        rowGap=\\"inherit\\"
        templateColumns=\\"repeat(2, auto)\\"
        {...getOverrideProps(overrides, \\"RowGrid0\\")}
      >
        <TextField
          label=\\"Username\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"john\\"
          defaultValue={username}
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username: value,
                caption,
                Customtags,
                tags,
                profile_url,
              };
              const result = onChange(modelFields);
              value = result?.username ?? value;
            }
            if (errors.username?.hasError) {
              runValidationTasks(\\"username\\", value);
            }
            setUsername(value);
          }}
          onBlur={() => runValidationTasks(\\"username\\", username)}
          errorMessage={errors.username?.errorMessage}
          hasError={errors.username?.hasError}
          {...getOverrideProps(overrides, \\"username\\")}
        ></TextField>
        <TextField
          label=\\"Caption\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"i love code\\"
          defaultValue={caption}
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username,
                caption: value,
                Customtags,
                tags,
                profile_url,
              };
              const result = onChange(modelFields);
              value = result?.caption ?? value;
            }
            if (errors.caption?.hasError) {
              runValidationTasks(\\"caption\\", value);
            }
            setCaption(value);
          }}
          onBlur={() => runValidationTasks(\\"caption\\", caption)}
          errorMessage={errors.caption?.errorMessage}
          hasError={errors.caption?.hasError}
          {...getOverrideProps(overrides, \\"caption\\")}
        ></TextField>
      </Grid>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags: values,
              tags,
              profile_url,
            };
            const result = onChange(modelFields);
            values = result?.Customtags ?? values;
          }
          setCustomtags(values);
          setCurrentCustomtagsValue(undefined);
        }}
        currentFieldValue={currentCustomtagsValue}
        label={\\"Tags\\"}
        items={Customtags}
        hasError={errors.Customtags?.hasError}
        setFieldValue={setCurrentCustomtagsValue}
        inputFieldRef={CustomtagsRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Tags\\"
          placeholder=\\"goals\\"
          value={currentCustomtagsValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.Customtags?.hasError) {
              runValidationTasks(\\"Customtags\\", value);
            }
            setCurrentCustomtagsValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"Customtags\\", currentCustomtagsValue)
          }
          errorMessage={errors.Customtags?.errorMessage}
          hasError={errors.Customtags?.hasError}
          ref={CustomtagsRef}
          {...getOverrideProps(overrides, \\"Customtags\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              tags: values,
              profile_url,
            };
            const result = onChange(modelFields);
            values = result?.tags ?? values;
          }
          setTags(values);
          setCurrentTagsValue(undefined);
        }}
        currentFieldValue={currentTagsValue}
        label={\\"Tags\\"}
        items={tags}
        hasError={errors.tags?.hasError}
        setFieldValue={setCurrentTagsValue}
        inputFieldRef={tagsRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Tags\\"
          isRequired={false}
          isReadOnly={false}
          value={currentTagsValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.tags?.hasError) {
              runValidationTasks(\\"tags\\", value);
            }
            setCurrentTagsValue(value);
          }}
          onBlur={() => runValidationTasks(\\"tags\\", currentTagsValue)}
          errorMessage={errors.tags?.errorMessage}
          hasError={errors.tags?.hasError}
          ref={tagsRef}
          {...getOverrideProps(overrides, \\"tags\\")}
        ></TextField>
      </ArrayField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={profile_url}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              tags,
              profile_url: value,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a create form with colliding model name 2`] = `
"import * as React from \\"react\\";
import { Flex as Flex0 } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyFlexUpdateFormInputValues = {
    username?: string;
    caption?: string;
    Customtags?: string[];
    tags?: string[];
    profile_url?: string;
};
export declare type MyFlexUpdateFormValidationValues = {
    username?: ValidationFunction<string>;
    caption?: ValidationFunction<string>;
    Customtags?: ValidationFunction<string>;
    tags?: ValidationFunction<string>;
    profile_url?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyFlexUpdateFormOverridesProps = {
    MyFlexUpdateFormGrid?: FormProps<GridProps>;
    RowGrid0?: FormProps<GridProps>;
    username?: FormProps<TextFieldProps>;
    caption?: FormProps<TextFieldProps>;
    Customtags?: FormProps<TextFieldProps>;
    tags?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type MyFlexUpdateFormProps = React.PropsWithChildren<{
    overrides?: MyFlexUpdateFormOverridesProps | undefined | null;
} & {
    id?: string;
    flex?: Flex0;
    onSubmit?: (fields: MyFlexUpdateFormInputValues) => MyFlexUpdateFormInputValues;
    onSuccess?: (fields: MyFlexUpdateFormInputValues) => void;
    onError?: (fields: MyFlexUpdateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyFlexUpdateFormInputValues) => MyFlexUpdateFormInputValues;
    onValidate?: MyFlexUpdateFormValidationValues;
} & React.CSSProperties>;
export default function MyFlexUpdateForm(props: MyFlexUpdateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with a javascript reserved word as the field name 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Blog } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  SwitchField,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function BlogCreateForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    title: undefined,
    content: undefined,
    switch: false,
    published: undefined,
    editedAt: [],
  };
  const [title, setTitle] = React.useState(initialValues.title);
  const [content, setContent] = React.useState(initialValues.content);
  const [switch1, setSwitch1] = React.useState(initialValues.switch);
  const [published, setPublished] = React.useState(initialValues.published);
  const [editedAt, setEditedAt] = React.useState(initialValues.editedAt);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setTitle(initialValues.title);
    setContent(initialValues.content);
    setSwitch1(initialValues.switch);
    setPublished(initialValues.published);
    setEditedAt(initialValues.editedAt);
    setCurrentEditedAtValue(undefined);
    setErrors({});
  };
  const [currentEditedAtValue, setCurrentEditedAtValue] =
    React.useState(undefined);
  const editedAtRef = React.createRef();
  const validations = {
    title: [],
    content: [],
    switch: [],
    published: [],
    editedAt: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  const convertTimeStampToDate = (ts) => {
    if (Math.abs(Date.now() - ts) < Math.abs(Date.now() - ts * 1000)) {
      return new Date(ts);
    }
    return new Date(ts * 1000);
  };
  const convertToLocal = (date) => {
    const df = new Intl.DateTimeFormat(\\"default\\", {
      year: \\"numeric\\",
      month: \\"2-digit\\",
      day: \\"2-digit\\",
      hour: \\"2-digit\\",
      minute: \\"2-digit\\",
      calendar: \\"iso8601\\",
      numberingSystem: \\"latn\\",
      hour12: false,
    });
    const parts = df.formatToParts(date).reduce((acc, part) => {
      acc[part.type] = part.value;
      return acc;
    }, {});
    return \`\${parts.year}-\${parts.month}-\${parts.day}T\${parts.hour}:\${parts.minute}\`;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          title,
          content,
          switch: switch1,
          published,
          editedAt,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Blog(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"BlogCreateForm\\")}
    >
      <TextField
        label=\\"Title\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              title: value,
              content,
              switch: switch1,
              published,
              editedAt,
            };
            const result = onChange(modelFields);
            value = result?.title ?? value;
          }
          if (errors.title?.hasError) {
            runValidationTasks(\\"title\\", value);
          }
          setTitle(value);
        }}
        onBlur={() => runValidationTasks(\\"title\\", title)}
        errorMessage={errors.title?.errorMessage}
        hasError={errors.title?.hasError}
        {...getOverrideProps(overrides, \\"title\\")}
      ></TextField>
      <TextField
        label=\\"Content\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              title,
              content: value,
              switch: switch1,
              published,
              editedAt,
            };
            const result = onChange(modelFields);
            value = result?.content ?? value;
          }
          if (errors.content?.hasError) {
            runValidationTasks(\\"content\\", value);
          }
          setContent(value);
        }}
        onBlur={() => runValidationTasks(\\"content\\", content)}
        errorMessage={errors.content?.errorMessage}
        hasError={errors.content?.hasError}
        {...getOverrideProps(overrides, \\"content\\")}
      ></TextField>
      <SwitchField
        label=\\"Switch\\"
        defaultChecked={false}
        isDisabled={false}
        isChecked={switch1}
        onChange={(e) => {
          let value = e.target.checked;
          if (onChange) {
            const modelFields = {
              title,
              content,
              switch: value,
              published,
              editedAt,
            };
            const result = onChange(modelFields);
            value = result?.switch ?? value;
          }
          if (errors.switch?.hasError) {
            runValidationTasks(\\"switch\\", value);
          }
          setSwitch1(value);
        }}
        onBlur={() => runValidationTasks(\\"switch\\", switch1)}
        errorMessage={errors.switch?.errorMessage}
        hasError={errors.switch?.hasError}
        {...getOverrideProps(overrides, \\"switch\\")}
      ></SwitchField>
      <TextField
        label=\\"Published\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"datetime-local\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              title,
              content,
              switch: switch1,
              published: value,
              editedAt,
            };
            const result = onChange(modelFields);
            value = result?.published ?? value;
          }
          if (errors.published?.hasError) {
            runValidationTasks(\\"published\\", value);
          }
          setPublished(new Date(value).toISOString());
        }}
        onBlur={() => runValidationTasks(\\"published\\", published)}
        errorMessage={errors.published?.errorMessage}
        hasError={errors.published?.hasError}
        {...getOverrideProps(overrides, \\"published\\")}
      ></TextField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              title,
              content,
              switch: switch1,
              published,
              editedAt: values,
            };
            const result = onChange(modelFields);
            values = result?.editedAt ?? values;
          }
          setEditedAt(values);
          setCurrentEditedAtValue(undefined);
        }}
        currentFieldValue={currentEditedAtValue}
        label={\\"Edited at\\"}
        items={editedAt}
        hasError={errors.editedAt?.hasError}
        setFieldValue={setCurrentEditedAtValue}
        inputFieldRef={editedAtRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Edited at\\"
          isRequired={false}
          isReadOnly={false}
          type=\\"datetime-local\\"
          value={
            currentEditedAtValue &&
            convertToLocal(convertTimeStampToDate(currentEditedAtValue))
          }
          onChange={(e) => {
            const date = new Date(e.target.value);
            if (!(date instanceof Date && !isNaN(date))) {
              setErrors((errors) => ({
                ...errors,
                editedAt: \\"The value must be a valid date\\",
              }));
              return;
            }
            let value = Number(date);
            if (errors.editedAt?.hasError) {
              runValidationTasks(\\"editedAt\\", value);
            }
            setCurrentEditedAtValue(value);
          }}
          onBlur={() => runValidationTasks(\\"editedAt\\", currentEditedAtValue)}
          errorMessage={errors.editedAt?.errorMessage}
          hasError={errors.editedAt?.hasError}
          ref={editedAtRef}
          {...getOverrideProps(overrides, \\"editedAt\\")}
        ></TextField>
      </ArrayField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with a javascript reserved word as the field name 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, SwitchFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type BlogCreateFormInputValues = {
    title?: string;
    content?: string;
    switch?: boolean;
    published?: string;
    editedAt?: number[];
};
export declare type BlogCreateFormValidationValues = {
    title?: ValidationFunction<string>;
    content?: ValidationFunction<string>;
    switch?: ValidationFunction<boolean>;
    published?: ValidationFunction<string>;
    editedAt?: ValidationFunction<number>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type BlogCreateFormOverridesProps = {
    BlogCreateFormGrid?: FormProps<GridProps>;
    title?: FormProps<TextFieldProps>;
    content?: FormProps<TextFieldProps>;
    switch?: FormProps<SwitchFieldProps>;
    published?: FormProps<TextFieldProps>;
    editedAt?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type BlogCreateFormProps = React.PropsWithChildren<{
    overrides?: BlogCreateFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: BlogCreateFormInputValues) => BlogCreateFormInputValues;
    onSuccess?: (fields: BlogCreateFormInputValues) => void;
    onError?: (fields: BlogCreateFormInputValues, errorMessage: string) => void;
    onChange?: (fields: BlogCreateFormInputValues) => BlogCreateFormInputValues;
    onValidate?: BlogCreateFormValidationValues;
} & React.CSSProperties>;
export default function BlogCreateForm(props: BlogCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { InputGallery } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  CheckboxField,
  Divider,
  Flex,
  Grid,
  Icon,
  Radio,
  RadioGroupField,
  ScrollView,
  Text,
  TextAreaField,
  TextField,
  ToggleButton,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function InputGalleryCreateForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    num: undefined,
    rootbeer: undefined,
    attend: undefined,
    maybeSlide: false,
    maybeCheck: false,
    arrayTypeField: [],
    jsonArray: [],
    jsonField: undefined,
    timestamp: undefined,
    ippy: undefined,
    timeisnow: undefined,
  };
  const [num, setNum] = React.useState(initialValues.num);
  const [rootbeer, setRootbeer] = React.useState(initialValues.rootbeer);
  const [attend, setAttend] = React.useState(initialValues.attend);
  const [maybeSlide, setMaybeSlide] = React.useState(initialValues.maybeSlide);
  const [maybeCheck, setMaybeCheck] = React.useState(initialValues.maybeCheck);
  const [arrayTypeField, setArrayTypeField] = React.useState(
    initialValues.arrayTypeField
  );
  const [jsonArray, setJsonArray] = React.useState(initialValues.jsonArray);
  const [jsonField, setJsonField] = React.useState(
    initialValues.jsonField
      ? JSON.stringify(initialValues.jsonField)
      : undefined
  );
  const [timestamp, setTimestamp] = React.useState(initialValues.timestamp);
  const [ippy, setIppy] = React.useState(initialValues.ippy);
  const [timeisnow, setTimeisnow] = React.useState(initialValues.timeisnow);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setNum(initialValues.num);
    setRootbeer(initialValues.rootbeer);
    setAttend(initialValues.attend);
    setMaybeSlide(initialValues.maybeSlide);
    setMaybeCheck(initialValues.maybeCheck);
    setArrayTypeField(initialValues.arrayTypeField);
    setCurrentArrayTypeFieldValue(undefined);
    setJsonArray(initialValues.jsonArray);
    setCurrentJsonArrayValue(undefined);
    setJsonField(initialValues.jsonField);
    setTimestamp(initialValues.timestamp);
    setIppy(initialValues.ippy);
    setTimeisnow(initialValues.timeisnow);
    setErrors({});
  };
  const [currentArrayTypeFieldValue, setCurrentArrayTypeFieldValue] =
    React.useState(undefined);
  const arrayTypeFieldRef = React.createRef();
  const [currentJsonArrayValue, setCurrentJsonArrayValue] =
    React.useState(undefined);
  const jsonArrayRef = React.createRef();
  const validations = {
    num: [],
    rootbeer: [],
    attend: [{ type: \\"Required\\" }],
    maybeSlide: [],
    maybeCheck: [],
    arrayTypeField: [],
    jsonArray: [{ type: \\"JSON\\" }],
    jsonField: [{ type: \\"JSON\\" }],
    timestamp: [],
    ippy: [{ type: \\"IpAddress\\" }],
    timeisnow: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          num,
          rootbeer,
          attend,
          maybeSlide,
          maybeCheck,
          arrayTypeField,
          jsonArray,
          jsonField,
          timestamp,
          ippy,
          timeisnow,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new InputGallery(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"InputGalleryCreateForm\\")}
    >
      <TextField
        label=\\"Num\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        step=\\"any\\"
        onChange={(e) => {
          let value = parseInt(e.target.value);
          if (isNaN(value)) {
            setErrors((errors) => ({
              ...errors,
              num: \\"Value must be a valid number\\",
            }));
            return;
          }
          if (onChange) {
            const modelFields = {
              num: value,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.num ?? value;
          }
          if (errors.num?.hasError) {
            runValidationTasks(\\"num\\", value);
          }
          setNum(value);
        }}
        onBlur={() => runValidationTasks(\\"num\\", num)}
        errorMessage={errors.num?.errorMessage}
        hasError={errors.num?.hasError}
        {...getOverrideProps(overrides, \\"num\\")}
      ></TextField>
      <TextField
        label=\\"Rootbeer\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        step=\\"any\\"
        onChange={(e) => {
          let value = Number(e.target.value);
          if (isNaN(value)) {
            setErrors((errors) => ({
              ...errors,
              rootbeer: \\"Value must be a valid number\\",
            }));
            return;
          }
          if (onChange) {
            const modelFields = {
              num,
              rootbeer: value,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.rootbeer ?? value;
          }
          if (errors.rootbeer?.hasError) {
            runValidationTasks(\\"rootbeer\\", value);
          }
          setRootbeer(value);
        }}
        onBlur={() => runValidationTasks(\\"rootbeer\\", rootbeer)}
        errorMessage={errors.rootbeer?.errorMessage}
        hasError={errors.rootbeer?.hasError}
        {...getOverrideProps(overrides, \\"rootbeer\\")}
      ></TextField>
      <RadioGroupField
        label=\\"Attend\\"
        name=\\"attend\\"
        isReadOnly={false}
        isRequired=\\"false\\"
        onChange={(e) => {
          let value = e.target.value === \\"true\\";
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend: value,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.attend ?? value;
          }
          if (errors.attend?.hasError) {
            runValidationTasks(\\"attend\\", value);
          }
          setAttend(value);
        }}
        onBlur={() => runValidationTasks(\\"attend\\", attend)}
        errorMessage={errors.attend?.errorMessage}
        hasError={errors.attend?.hasError}
        {...getOverrideProps(overrides, \\"attend\\")}
      >
        <Radio
          children=\\"Yes\\"
          value=\\"true\\"
          {...getOverrideProps(overrides, \\"attendRadio0\\")}
        ></Radio>
        <Radio
          children=\\"No\\"
          value=\\"false\\"
          {...getOverrideProps(overrides, \\"attendRadio1\\")}
        ></Radio>
      </RadioGroupField>
      <ToggleButton
        children=\\"Maybe slide\\"
        isDisabled={false}
        defaultPressed={false}
        isPressed={maybeSlide}
        onChange={(e) => {
          let value = !maybeSlide;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide: value,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeSlide ?? value;
          }
          if (errors.maybeSlide?.hasError) {
            runValidationTasks(\\"maybeSlide\\", value);
          }
          setMaybeSlide(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeSlide\\", maybeSlide)}
        errorMessage={errors.maybeSlide?.errorMessage}
        hasError={errors.maybeSlide?.hasError}
        {...getOverrideProps(overrides, \\"maybeSlide\\")}
      ></ToggleButton>
      <CheckboxField
        label=\\"Maybe check\\"
        name=\\"maybeCheck\\"
        value=\\"maybeCheck\\"
        isDisabled={false}
        checked={maybeCheck}
        onChange={(e) => {
          let value = e.target.checked;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck: value,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeCheck ?? value;
          }
          if (errors.maybeCheck?.hasError) {
            runValidationTasks(\\"maybeCheck\\", value);
          }
          setMaybeCheck(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeCheck\\", maybeCheck)}
        errorMessage={errors.maybeCheck?.errorMessage}
        hasError={errors.maybeCheck?.hasError}
        {...getOverrideProps(overrides, \\"maybeCheck\\")}
      ></CheckboxField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField: values,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            values = result?.arrayTypeField ?? values;
          }
          setArrayTypeField(values);
          setCurrentArrayTypeFieldValue(undefined);
        }}
        currentFieldValue={currentArrayTypeFieldValue}
        label={\\"Array type field\\"}
        items={arrayTypeField}
        hasError={errors.arrayTypeField?.hasError}
        setFieldValue={setCurrentArrayTypeFieldValue}
        inputFieldRef={arrayTypeFieldRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Array type field\\"
          isRequired={false}
          isReadOnly={false}
          value={currentArrayTypeFieldValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.arrayTypeField?.hasError) {
              runValidationTasks(\\"arrayTypeField\\", value);
            }
            setCurrentArrayTypeFieldValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"arrayTypeField\\", currentArrayTypeFieldValue)
          }
          errorMessage={errors.arrayTypeField?.errorMessage}
          hasError={errors.arrayTypeField?.hasError}
          ref={arrayTypeFieldRef}
          {...getOverrideProps(overrides, \\"arrayTypeField\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray: values,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            values = result?.jsonArray ?? values;
          }
          setJsonArray(values);
          setCurrentJsonArrayValue(undefined);
        }}
        currentFieldValue={currentJsonArrayValue}
        label={\\"Json array\\"}
        items={jsonArray}
        hasError={errors.jsonArray?.hasError}
        setFieldValue={setCurrentJsonArrayValue}
        inputFieldRef={jsonArrayRef}
        defaultFieldValue={undefined}
      >
        <TextAreaField
          label=\\"Json array\\"
          isRequired={false}
          isReadOnly={false}
          value={currentJsonArrayValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.jsonArray?.hasError) {
              runValidationTasks(\\"jsonArray\\", value);
            }
            setCurrentJsonArrayValue(value);
          }}
          onBlur={() => runValidationTasks(\\"jsonArray\\", currentJsonArrayValue)}
          errorMessage={errors.jsonArray?.errorMessage}
          hasError={errors.jsonArray?.hasError}
          ref={jsonArrayRef}
          {...getOverrideProps(overrides, \\"jsonArray\\")}
        ></TextAreaField>
      </ArrayField>
      <TextAreaField
        label=\\"Json field\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField: value,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.jsonField ?? value;
          }
          if (errors.jsonField?.hasError) {
            runValidationTasks(\\"jsonField\\", value);
          }
          setJsonField(value);
        }}
        onBlur={() => runValidationTasks(\\"jsonField\\", jsonField)}
        errorMessage={errors.jsonField?.errorMessage}
        hasError={errors.jsonField?.hasError}
        {...getOverrideProps(overrides, \\"jsonField\\")}
      ></TextAreaField>
      <TextField
        label=\\"Timestamp\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"datetime-local\\"
        onChange={(e) => {
          const date = new Date(e.target.value);
          if (!(date instanceof Date && !isNaN(date))) {
            setErrors((errors) => ({
              ...errors,
              timestamp: \\"The value must be a valid date\\",
            }));
            return;
          }
          let value = Number(date);
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp: value,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.timestamp ?? value;
          }
          if (errors.timestamp?.hasError) {
            runValidationTasks(\\"timestamp\\", value);
          }
          setTimestamp(value);
        }}
        onBlur={() => runValidationTasks(\\"timestamp\\", timestamp)}
        errorMessage={errors.timestamp?.errorMessage}
        hasError={errors.timestamp?.hasError}
        {...getOverrideProps(overrides, \\"timestamp\\")}
      ></TextField>
      <TextField
        label=\\"Ippy\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy: value,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.ippy ?? value;
          }
          if (errors.ippy?.hasError) {
            runValidationTasks(\\"ippy\\", value);
          }
          setIppy(value);
        }}
        onBlur={() => runValidationTasks(\\"ippy\\", ippy)}
        errorMessage={errors.ippy?.errorMessage}
        hasError={errors.ippy?.hasError}
        {...getOverrideProps(overrides, \\"ippy\\")}
      ></TextField>
      <TextField
        label=\\"Timeisnow\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"time\\"
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow: value,
            };
            const result = onChange(modelFields);
            value = result?.timeisnow ?? value;
          }
          if (errors.timeisnow?.hasError) {
            runValidationTasks(\\"timeisnow\\", value);
          }
          setTimeisnow(value);
        }}
        onBlur={() => runValidationTasks(\\"timeisnow\\", timeisnow)}
        errorMessage={errors.timeisnow?.errorMessage}
        hasError={errors.timeisnow?.hasError}
        {...getOverrideProps(overrides, \\"timeisnow\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { CheckboxFieldProps, GridProps, RadioGroupFieldProps, TextAreaFieldProps, TextFieldProps, ToggleButtonProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type InputGalleryCreateFormInputValues = {
    num?: number;
    rootbeer?: number;
    attend?: boolean;
    maybeSlide?: boolean;
    maybeCheck?: boolean;
    arrayTypeField?: string[];
    jsonArray?: string[];
    jsonField?: string;
    timestamp?: number;
    ippy?: string;
    timeisnow?: string;
};
export declare type InputGalleryCreateFormValidationValues = {
    num?: ValidationFunction<number>;
    rootbeer?: ValidationFunction<number>;
    attend?: ValidationFunction<boolean>;
    maybeSlide?: ValidationFunction<boolean>;
    maybeCheck?: ValidationFunction<boolean>;
    arrayTypeField?: ValidationFunction<string>;
    jsonArray?: ValidationFunction<string>;
    jsonField?: ValidationFunction<string>;
    timestamp?: ValidationFunction<number>;
    ippy?: ValidationFunction<string>;
    timeisnow?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type InputGalleryCreateFormOverridesProps = {
    InputGalleryCreateFormGrid?: FormProps<GridProps>;
    num?: FormProps<TextFieldProps>;
    rootbeer?: FormProps<TextFieldProps>;
    attend?: FormProps<RadioGroupFieldProps>;
    maybeSlide?: FormProps<ToggleButtonProps>;
    maybeCheck?: FormProps<CheckboxFieldProps>;
    arrayTypeField?: FormProps<TextFieldProps>;
    jsonArray?: FormProps<TextAreaFieldProps>;
    jsonField?: FormProps<TextAreaFieldProps>;
    timestamp?: FormProps<TextFieldProps>;
    ippy?: FormProps<TextFieldProps>;
    timeisnow?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type InputGalleryCreateFormProps = React.PropsWithChildren<{
    overrides?: InputGalleryCreateFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: InputGalleryCreateFormInputValues) => InputGalleryCreateFormInputValues;
    onSuccess?: (fields: InputGalleryCreateFormInputValues) => void;
    onError?: (fields: InputGalleryCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: InputGalleryCreateFormInputValues) => InputGalleryCreateFormInputValues;
    onValidate?: InputGalleryCreateFormValidationValues;
} & React.CSSProperties>;
export default function InputGalleryCreateForm(props: InputGalleryCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 3`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { InputGallery } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  CheckboxField,
  Divider,
  Flex,
  Grid,
  Icon,
  Radio,
  RadioGroupField,
  ScrollView,
  Text,
  TextAreaField,
  TextField,
  ToggleButton,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function InputGalleryUpdateForm(props) {
  const {
    id,
    inputGallery,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    num: undefined,
    rootbeer: undefined,
    attend: undefined,
    maybeSlide: false,
    maybeCheck: false,
    arrayTypeField: [],
    jsonArray: [],
    jsonField: undefined,
    timestamp: undefined,
    ippy: undefined,
    timeisnow: undefined,
  };
  const [num, setNum] = React.useState(initialValues.num);
  const [rootbeer, setRootbeer] = React.useState(initialValues.rootbeer);
  const [attend, setAttend] = React.useState(initialValues.attend);
  const [maybeSlide, setMaybeSlide] = React.useState(initialValues.maybeSlide);
  const [maybeCheck, setMaybeCheck] = React.useState(initialValues.maybeCheck);
  const [arrayTypeField, setArrayTypeField] = React.useState(
    initialValues.arrayTypeField
  );
  const [jsonArray, setJsonArray] = React.useState(initialValues.jsonArray);
  const [jsonField, setJsonField] = React.useState(
    initialValues.jsonField
      ? JSON.stringify(initialValues.jsonField)
      : undefined
  );
  const [timestamp, setTimestamp] = React.useState(initialValues.timestamp);
  const [ippy, setIppy] = React.useState(initialValues.ippy);
  const [timeisnow, setTimeisnow] = React.useState(initialValues.timeisnow);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    const cleanValues = { ...initialValues, ...inputGalleryRecord };
    setNum(cleanValues.num);
    setRootbeer(cleanValues.rootbeer);
    setAttend(cleanValues.attend);
    setMaybeSlide(cleanValues.maybeSlide);
    setMaybeCheck(cleanValues.maybeCheck);
    setArrayTypeField(cleanValues.arrayTypeField ?? []);
    setCurrentArrayTypeFieldValue(undefined);
    setJsonArray(cleanValues.jsonArray ?? []);
    setCurrentJsonArrayValue(undefined);
    setJsonField(
      typeof cleanValues.jsonField === \\"string\\"
        ? cleanValues.jsonField
        : JSON.stringify(cleanValues.jsonField)
    );
    setTimestamp(cleanValues.timestamp);
    setIppy(cleanValues.ippy);
    setTimeisnow(cleanValues.timeisnow);
    setErrors({});
  };
  const [inputGalleryRecord, setInputGalleryRecord] =
    React.useState(inputGallery);
  React.useEffect(() => {
    const queryData = async () => {
      const record = id
        ? await DataStore.query(InputGallery, id)
        : inputGallery;
      setInputGalleryRecord(record);
    };
    queryData();
  }, [id, inputGallery]);
  React.useEffect(resetStateValues, [inputGalleryRecord]);
  const [currentArrayTypeFieldValue, setCurrentArrayTypeFieldValue] =
    React.useState(undefined);
  const arrayTypeFieldRef = React.createRef();
  const [currentJsonArrayValue, setCurrentJsonArrayValue] =
    React.useState(undefined);
  const jsonArrayRef = React.createRef();
  const validations = {
    num: [],
    rootbeer: [],
    attend: [{ type: \\"Required\\" }],
    maybeSlide: [],
    maybeCheck: [],
    arrayTypeField: [],
    jsonArray: [{ type: \\"JSON\\" }],
    jsonField: [{ type: \\"JSON\\" }],
    timestamp: [],
    ippy: [{ type: \\"IpAddress\\" }],
    timeisnow: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  const convertTimeStampToDate = (ts) => {
    if (Math.abs(Date.now() - ts) < Math.abs(Date.now() - ts * 1000)) {
      return new Date(ts);
    }
    return new Date(ts * 1000);
  };
  const convertToLocal = (date) => {
    const df = new Intl.DateTimeFormat(\\"default\\", {
      year: \\"numeric\\",
      month: \\"2-digit\\",
      day: \\"2-digit\\",
      hour: \\"2-digit\\",
      minute: \\"2-digit\\",
      calendar: \\"iso8601\\",
      numberingSystem: \\"latn\\",
      hour12: false,
    });
    const parts = df.formatToParts(date).reduce((acc, part) => {
      acc[part.type] = part.value;
      return acc;
    }, {});
    return \`\${parts.year}-\${parts.month}-\${parts.day}T\${parts.hour}:\${parts.minute}\`;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          num,
          rootbeer,
          attend,
          maybeSlide,
          maybeCheck,
          arrayTypeField,
          jsonArray,
          jsonField,
          timestamp,
          ippy,
          timeisnow,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          const original = await DataStore.query(InputGallery, id);
          await DataStore.save(
            InputGallery.copyOf(original, (updated) => {
              Object.assign(updated, modelFields);
            })
          );
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"InputGalleryUpdateForm\\")}
    >
      <TextField
        label=\\"Num\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        step=\\"any\\"
        defaultValue={num}
        onChange={(e) => {
          let value = parseInt(e.target.value);
          if (isNaN(value)) {
            setErrors((errors) => ({
              ...errors,
              num: \\"Value must be a valid number\\",
            }));
            return;
          }
          if (onChange) {
            const modelFields = {
              num: value,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.num ?? value;
          }
          if (errors.num?.hasError) {
            runValidationTasks(\\"num\\", value);
          }
          setNum(value);
        }}
        onBlur={() => runValidationTasks(\\"num\\", num)}
        errorMessage={errors.num?.errorMessage}
        hasError={errors.num?.hasError}
        {...getOverrideProps(overrides, \\"num\\")}
      ></TextField>
      <TextField
        label=\\"Rootbeer\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        step=\\"any\\"
        defaultValue={rootbeer}
        onChange={(e) => {
          let value = Number(e.target.value);
          if (isNaN(value)) {
            setErrors((errors) => ({
              ...errors,
              rootbeer: \\"Value must be a valid number\\",
            }));
            return;
          }
          if (onChange) {
            const modelFields = {
              num,
              rootbeer: value,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.rootbeer ?? value;
          }
          if (errors.rootbeer?.hasError) {
            runValidationTasks(\\"rootbeer\\", value);
          }
          setRootbeer(value);
        }}
        onBlur={() => runValidationTasks(\\"rootbeer\\", rootbeer)}
        errorMessage={errors.rootbeer?.errorMessage}
        hasError={errors.rootbeer?.hasError}
        {...getOverrideProps(overrides, \\"rootbeer\\")}
      ></TextField>
      <RadioGroupField
        label=\\"Attend\\"
        name=\\"attend\\"
        isReadOnly={false}
        isRequired=\\"false\\"
        defaultValue={attend}
        onChange={(e) => {
          let value = e.target.value === \\"true\\";
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend: value,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.attend ?? value;
          }
          if (errors.attend?.hasError) {
            runValidationTasks(\\"attend\\", value);
          }
          setAttend(value);
        }}
        onBlur={() => runValidationTasks(\\"attend\\", attend)}
        errorMessage={errors.attend?.errorMessage}
        hasError={errors.attend?.hasError}
        {...getOverrideProps(overrides, \\"attend\\")}
      >
        <Radio
          children=\\"Yes\\"
          value=\\"true\\"
          {...getOverrideProps(overrides, \\"attendRadio0\\")}
        ></Radio>
        <Radio
          children=\\"No\\"
          value=\\"false\\"
          {...getOverrideProps(overrides, \\"attendRadio1\\")}
        ></Radio>
      </RadioGroupField>
      <ToggleButton
        children=\\"Maybe slide\\"
        isDisabled={false}
        defaultPressed={false}
        isPressed={maybeSlide}
        onChange={(e) => {
          let value = !maybeSlide;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide: value,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeSlide ?? value;
          }
          if (errors.maybeSlide?.hasError) {
            runValidationTasks(\\"maybeSlide\\", value);
          }
          setMaybeSlide(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeSlide\\", maybeSlide)}
        errorMessage={errors.maybeSlide?.errorMessage}
        hasError={errors.maybeSlide?.hasError}
        {...getOverrideProps(overrides, \\"maybeSlide\\")}
      ></ToggleButton>
      <CheckboxField
        label=\\"Maybe check\\"
        name=\\"maybeCheck\\"
        value=\\"maybeCheck\\"
        isDisabled={false}
        checked={maybeCheck}
        defaultValue={maybeCheck}
        onChange={(e) => {
          let value = e.target.checked;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck: value,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeCheck ?? value;
          }
          if (errors.maybeCheck?.hasError) {
            runValidationTasks(\\"maybeCheck\\", value);
          }
          setMaybeCheck(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeCheck\\", maybeCheck)}
        errorMessage={errors.maybeCheck?.errorMessage}
        hasError={errors.maybeCheck?.hasError}
        {...getOverrideProps(overrides, \\"maybeCheck\\")}
      ></CheckboxField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField: values,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            values = result?.arrayTypeField ?? values;
          }
          setArrayTypeField(values);
          setCurrentArrayTypeFieldValue(undefined);
        }}
        currentFieldValue={currentArrayTypeFieldValue}
        label={\\"Array type field\\"}
        items={arrayTypeField}
        hasError={errors.arrayTypeField?.hasError}
        setFieldValue={setCurrentArrayTypeFieldValue}
        inputFieldRef={arrayTypeFieldRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Array type field\\"
          isRequired={false}
          isReadOnly={false}
          value={currentArrayTypeFieldValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.arrayTypeField?.hasError) {
              runValidationTasks(\\"arrayTypeField\\", value);
            }
            setCurrentArrayTypeFieldValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"arrayTypeField\\", currentArrayTypeFieldValue)
          }
          errorMessage={errors.arrayTypeField?.errorMessage}
          hasError={errors.arrayTypeField?.hasError}
          ref={arrayTypeFieldRef}
          {...getOverrideProps(overrides, \\"arrayTypeField\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray: values,
              jsonField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            values = result?.jsonArray ?? values;
          }
          setJsonArray(values);
          setCurrentJsonArrayValue(undefined);
        }}
        currentFieldValue={currentJsonArrayValue}
        label={\\"Json array\\"}
        items={jsonArray}
        hasError={errors.jsonArray?.hasError}
        setFieldValue={setCurrentJsonArrayValue}
        inputFieldRef={jsonArrayRef}
        defaultFieldValue={undefined}
      >
        <TextAreaField
          label=\\"Json array\\"
          isRequired={false}
          isReadOnly={false}
          value={currentJsonArrayValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.jsonArray?.hasError) {
              runValidationTasks(\\"jsonArray\\", value);
            }
            setCurrentJsonArrayValue(value);
          }}
          onBlur={() => runValidationTasks(\\"jsonArray\\", currentJsonArrayValue)}
          errorMessage={errors.jsonArray?.errorMessage}
          hasError={errors.jsonArray?.hasError}
          ref={jsonArrayRef}
          {...getOverrideProps(overrides, \\"jsonArray\\")}
        ></TextAreaField>
      </ArrayField>
      <TextAreaField
        label=\\"Json field\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={jsonField}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField: value,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.jsonField ?? value;
          }
          if (errors.jsonField?.hasError) {
            runValidationTasks(\\"jsonField\\", value);
          }
          setJsonField(value);
        }}
        onBlur={() => runValidationTasks(\\"jsonField\\", jsonField)}
        errorMessage={errors.jsonField?.errorMessage}
        hasError={errors.jsonField?.hasError}
        {...getOverrideProps(overrides, \\"jsonField\\")}
      ></TextAreaField>
      <TextField
        label=\\"Timestamp\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"datetime-local\\"
        defaultValue={
          timestamp && convertToLocal(convertTimeStampToDate(timestamp))
        }
        onChange={(e) => {
          const date = new Date(e.target.value);
          if (!(date instanceof Date && !isNaN(date))) {
            setErrors((errors) => ({
              ...errors,
              timestamp: \\"The value must be a valid date\\",
            }));
            return;
          }
          let value = Number(date);
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp: value,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.timestamp ?? value;
          }
          if (errors.timestamp?.hasError) {
            runValidationTasks(\\"timestamp\\", value);
          }
          setTimestamp(value);
        }}
        onBlur={() => runValidationTasks(\\"timestamp\\", timestamp)}
        errorMessage={errors.timestamp?.errorMessage}
        hasError={errors.timestamp?.hasError}
        {...getOverrideProps(overrides, \\"timestamp\\")}
      ></TextField>
      <TextField
        label=\\"Ippy\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={ippy}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy: value,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.ippy ?? value;
          }
          if (errors.ippy?.hasError) {
            runValidationTasks(\\"ippy\\", value);
          }
          setIppy(value);
        }}
        onBlur={() => runValidationTasks(\\"ippy\\", ippy)}
        errorMessage={errors.ippy?.errorMessage}
        hasError={errors.ippy?.hasError}
        {...getOverrideProps(overrides, \\"ippy\\")}
      ></TextField>
      <TextField
        label=\\"Timeisnow\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"time\\"
        defaultValue={timeisnow}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              jsonArray,
              jsonField,
              timestamp,
              ippy,
              timeisnow: value,
            };
            const result = onChange(modelFields);
            value = result?.timeisnow ?? value;
          }
          if (errors.timeisnow?.hasError) {
            runValidationTasks(\\"timeisnow\\", value);
          }
          setTimeisnow(value);
        }}
        onBlur={() => runValidationTasks(\\"timeisnow\\", timeisnow)}
        errorMessage={errors.timeisnow?.errorMessage}
        hasError={errors.timeisnow?.hasError}
        {...getOverrideProps(overrides, \\"timeisnow\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Reset\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ResetButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 4`] = `
"import * as React from \\"react\\";
import { InputGallery } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { CheckboxFieldProps, GridProps, RadioGroupFieldProps, TextAreaFieldProps, TextFieldProps, ToggleButtonProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type InputGalleryUpdateFormInputValues = {
    num?: number;
    rootbeer?: number;
    attend?: boolean;
    maybeSlide?: boolean;
    maybeCheck?: boolean;
    arrayTypeField?: string[];
    jsonArray?: string[];
    jsonField?: string;
    timestamp?: number;
    ippy?: string;
    timeisnow?: string;
};
export declare type InputGalleryUpdateFormValidationValues = {
    num?: ValidationFunction<number>;
    rootbeer?: ValidationFunction<number>;
    attend?: ValidationFunction<boolean>;
    maybeSlide?: ValidationFunction<boolean>;
    maybeCheck?: ValidationFunction<boolean>;
    arrayTypeField?: ValidationFunction<string>;
    jsonArray?: ValidationFunction<string>;
    jsonField?: ValidationFunction<string>;
    timestamp?: ValidationFunction<number>;
    ippy?: ValidationFunction<string>;
    timeisnow?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type InputGalleryUpdateFormOverridesProps = {
    InputGalleryUpdateFormGrid?: FormProps<GridProps>;
    num?: FormProps<TextFieldProps>;
    rootbeer?: FormProps<TextFieldProps>;
    attend?: FormProps<RadioGroupFieldProps>;
    maybeSlide?: FormProps<ToggleButtonProps>;
    maybeCheck?: FormProps<CheckboxFieldProps>;
    arrayTypeField?: FormProps<TextFieldProps>;
    jsonArray?: FormProps<TextAreaFieldProps>;
    jsonField?: FormProps<TextAreaFieldProps>;
    timestamp?: FormProps<TextFieldProps>;
    ippy?: FormProps<TextFieldProps>;
    timeisnow?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type InputGalleryUpdateFormProps = React.PropsWithChildren<{
    overrides?: InputGalleryUpdateFormOverridesProps | undefined | null;
} & {
    id?: string;
    inputGallery?: InputGallery;
    onSubmit?: (fields: InputGalleryUpdateFormInputValues) => InputGalleryUpdateFormInputValues;
    onSuccess?: (fields: InputGalleryUpdateFormInputValues) => void;
    onError?: (fields: InputGalleryUpdateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: InputGalleryUpdateFormInputValues) => InputGalleryUpdateFormInputValues;
    onValidate?: InputGalleryUpdateFormValidationValues;
} & React.CSSProperties>;
export default function InputGalleryUpdateForm(props: InputGalleryUpdateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a update form with colliding model name 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Flex as Flex0 } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function MyFlexCreateForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    username: undefined,
    caption: undefined,
    Customtags: [],
    tags: [],
    profile_url: undefined,
  };
  const [username, setUsername] = React.useState(initialValues.username);
  const [caption, setCaption] = React.useState(initialValues.caption);
  const [Customtags, setCustomtags] = React.useState(initialValues.Customtags);
  const [tags, setTags] = React.useState(initialValues.tags);
  const [profile_url, setProfile_url] = React.useState(
    initialValues.profile_url
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setUsername(initialValues.username);
    setCaption(initialValues.caption);
    setCustomtags(initialValues.Customtags);
    setCurrentCustomtagsValue(undefined);
    setTags(initialValues.tags);
    setCurrentTagsValue(undefined);
    setProfile_url(initialValues.profile_url);
    setErrors({});
  };
  const [currentCustomtagsValue, setCurrentCustomtagsValue] =
    React.useState(undefined);
  const CustomtagsRef = React.createRef();
  const [currentTagsValue, setCurrentTagsValue] = React.useState(undefined);
  const tagsRef = React.createRef();
  const validations = {
    username: [
      {
        type: \\"GreaterThanChar\\",
        numValues: [2],
        validationMessage: \\"needs to be of length 2\\",
      },
    ],
    caption: [],
    Customtags: [],
    tags: [],
    profile_url: [{ type: \\"URL\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          username,
          caption,
          Customtags,
          tags,
          profile_url: profile_url || undefined,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Flex0(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyFlexCreateForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <Grid
        columnGap=\\"inherit\\"
        rowGap=\\"inherit\\"
        templateColumns=\\"repeat(2, auto)\\"
        {...getOverrideProps(overrides, \\"RowGrid0\\")}
      >
        <TextField
          label=\\"Username\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"john\\"
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username: value,
                caption,
                Customtags,
                tags,
                profile_url,
              };
              const result = onChange(modelFields);
              value = result?.username ?? value;
            }
            if (errors.username?.hasError) {
              runValidationTasks(\\"username\\", value);
            }
            setUsername(value);
          }}
          onBlur={() => runValidationTasks(\\"username\\", username)}
          errorMessage={errors.username?.errorMessage}
          hasError={errors.username?.hasError}
          {...getOverrideProps(overrides, \\"username\\")}
        ></TextField>
        <TextField
          label=\\"Caption\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"i love code\\"
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username,
                caption: value,
                Customtags,
                tags,
                profile_url,
              };
              const result = onChange(modelFields);
              value = result?.caption ?? value;
            }
            if (errors.caption?.hasError) {
              runValidationTasks(\\"caption\\", value);
            }
            setCaption(value);
          }}
          onBlur={() => runValidationTasks(\\"caption\\", caption)}
          errorMessage={errors.caption?.errorMessage}
          hasError={errors.caption?.hasError}
          {...getOverrideProps(overrides, \\"caption\\")}
        ></TextField>
      </Grid>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags: values,
              tags,
              profile_url,
            };
            const result = onChange(modelFields);
            values = result?.Customtags ?? values;
          }
          setCustomtags(values);
          setCurrentCustomtagsValue(undefined);
        }}
        currentFieldValue={currentCustomtagsValue}
        label={\\"Tags\\"}
        items={Customtags}
        hasError={errors.Customtags?.hasError}
        setFieldValue={setCurrentCustomtagsValue}
        inputFieldRef={CustomtagsRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Tags\\"
          placeholder=\\"goals\\"
          value={currentCustomtagsValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.Customtags?.hasError) {
              runValidationTasks(\\"Customtags\\", value);
            }
            setCurrentCustomtagsValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"Customtags\\", currentCustomtagsValue)
          }
          errorMessage={errors.Customtags?.errorMessage}
          hasError={errors.Customtags?.hasError}
          ref={CustomtagsRef}
          {...getOverrideProps(overrides, \\"Customtags\\")}
        ></TextField>
      </ArrayField>
      <ArrayField
        onChange={async (items) => {
          let values = items;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              tags: values,
              profile_url,
            };
            const result = onChange(modelFields);
            values = result?.tags ?? values;
          }
          setTags(values);
          setCurrentTagsValue(undefined);
        }}
        currentFieldValue={currentTagsValue}
        label={\\"Tags\\"}
        items={tags}
        hasError={errors.tags?.hasError}
        setFieldValue={setCurrentTagsValue}
        inputFieldRef={tagsRef}
        defaultFieldValue={undefined}
      >
        <TextField
          label=\\"Tags\\"
          isRequired={false}
          isReadOnly={false}
          value={currentTagsValue}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.tags?.hasError) {
              runValidationTasks(\\"tags\\", value);
            }
            setCurrentTagsValue(value);
          }}
          onBlur={() => runValidationTasks(\\"tags\\", currentTagsValue)}
          errorMessage={errors.tags?.errorMessage}
          hasError={errors.tags?.hasError}
          ref={tagsRef}
          {...getOverrideProps(overrides, \\"tags\\")}
        ></TextField>
      </ArrayField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              Customtags,
              tags,
              profile_url: value,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a update form with colliding model name 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyFlexCreateFormInputValues = {
    username?: string;
    caption?: string;
    Customtags?: string[];
    tags?: string[];
    profile_url?: string;
};
export declare type MyFlexCreateFormValidationValues = {
    username?: ValidationFunction<string>;
    caption?: ValidationFunction<string>;
    Customtags?: ValidationFunction<string>;
    tags?: ValidationFunction<string>;
    profile_url?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyFlexCreateFormOverridesProps = {
    MyFlexCreateFormGrid?: FormProps<GridProps>;
    RowGrid0?: FormProps<GridProps>;
    username?: FormProps<TextFieldProps>;
    caption?: FormProps<TextFieldProps>;
    Customtags?: FormProps<TextFieldProps>;
    tags?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type MyFlexCreateFormProps = React.PropsWithChildren<{
    overrides?: MyFlexCreateFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: MyFlexCreateFormInputValues) => MyFlexCreateFormInputValues;
    onSuccess?: (fields: MyFlexCreateFormInputValues) => void;
    onError?: (fields: MyFlexCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyFlexCreateFormInputValues) => MyFlexCreateFormInputValues;
    onValidate?: MyFlexCreateFormValidationValues;
} & React.CSSProperties>;
export default function MyFlexCreateForm(props: MyFlexCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render form with a two inputs in row 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  SelectField,
  TextAreaField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
export default function PostCreateFormRow(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    username: undefined,
    caption: undefined,
    post_url: undefined,
    profile_url: undefined,
    status: undefined,
    metadata: undefined,
  };
  const [username, setUsername] = React.useState(initialValues.username);
  const [caption, setCaption] = React.useState(initialValues.caption);
  const [post_url, setPost_url] = React.useState(initialValues.post_url);
  const [profile_url, setProfile_url] = React.useState(
    initialValues.profile_url
  );
  const [status, setStatus] = React.useState(initialValues.status);
  const [metadata, setMetadata] = React.useState(
    initialValues.metadata ? JSON.stringify(initialValues.metadata) : undefined
  );
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setUsername(initialValues.username);
    setCaption(initialValues.caption);
    setPost_url(initialValues.post_url);
    setProfile_url(initialValues.profile_url);
    setStatus(initialValues.status);
    setMetadata(initialValues.metadata);
    setErrors({});
  };
  const validations = {
    username: [
      {
        type: \\"GreaterThanChar\\",
        numValues: [2],
        validationMessage: \\"needs to be of length 2\\",
      },
    ],
    caption: [],
    post_url: [{ type: \\"URL\\" }],
    profile_url: [{ type: \\"URL\\" }],
    status: [],
    metadata: [{ type: \\"JSON\\" }],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          username,
          caption,
          post_url: post_url || undefined,
          profile_url: profile_url || undefined,
          status,
          metadata,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Post(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"PostCreateFormRow\\")}
    >
      <Grid
        columnGap=\\"inherit\\"
        rowGap=\\"inherit\\"
        templateColumns=\\"repeat(2, auto)\\"
        {...getOverrideProps(overrides, \\"RowGrid0\\")}
      >
        <TextField
          label=\\"Username\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"john\\"
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username: value,
                caption,
                post_url,
                profile_url,
                status,
                metadata,
              };
              const result = onChange(modelFields);
              value = result?.username ?? value;
            }
            if (errors.username?.hasError) {
              runValidationTasks(\\"username\\", value);
            }
            setUsername(value);
          }}
          onBlur={() => runValidationTasks(\\"username\\", username)}
          errorMessage={errors.username?.errorMessage}
          hasError={errors.username?.hasError}
          {...getOverrideProps(overrides, \\"username\\")}
        ></TextField>
        <TextField
          label=\\"Caption\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"i love code\\"
          onChange={(e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username,
                caption: value,
                post_url,
                profile_url,
                status,
                metadata,
              };
              const result = onChange(modelFields);
              value = result?.caption ?? value;
            }
            if (errors.caption?.hasError) {
              runValidationTasks(\\"caption\\", value);
            }
            setCaption(value);
          }}
          onBlur={() => runValidationTasks(\\"caption\\", caption)}
          errorMessage={errors.caption?.errorMessage}
          hasError={errors.caption?.hasError}
          {...getOverrideProps(overrides, \\"caption\\")}
        ></TextField>
      </Grid>
      <TextField
        label=\\"Post url\\"
        descriptiveText=\\"post url to use for the component\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url: value,
              profile_url,
              status,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <TextField
        label=\\"Profile url\\"
        descriptiveText=\\"profile image url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url,
              profile_url: value,
              status,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
      <SelectField
        label=\\"Label\\"
        placeholder=\\"Please select an option\\"
        value={status}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url,
              profile_url,
              status: value,
              metadata,
            };
            const result = onChange(modelFields);
            value = result?.status ?? value;
          }
          if (errors.status?.hasError) {
            runValidationTasks(\\"status\\", value);
          }
          setStatus(value);
        }}
        onBlur={() => runValidationTasks(\\"status\\", status)}
        errorMessage={errors.status?.errorMessage}
        hasError={errors.status?.hasError}
        {...getOverrideProps(overrides, \\"status\\")}
      ></SelectField>
      <TextAreaField
        label=\\"Metadata\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url,
              profile_url,
              status,
              metadata: value,
            };
            const result = onChange(modelFields);
            value = result?.metadata ?? value;
          }
          if (errors.metadata?.hasError) {
            runValidationTasks(\\"metadata\\", value);
          }
          setMetadata(value);
        }}
        onBlur={() => runValidationTasks(\\"metadata\\", metadata)}
        errorMessage={errors.metadata?.errorMessage}
        hasError={errors.metadata?.hasError}
        {...getOverrideProps(overrides, \\"metadata\\")}
      ></TextAreaField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render form with a two inputs in row 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, SelectFieldProps, TextAreaFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type PostCreateFormRowInputValues = {
    username?: string;
    caption?: string;
    post_url?: string;
    profile_url?: string;
    status?: string;
    metadata?: string;
};
export declare type PostCreateFormRowValidationValues = {
    username?: ValidationFunction<string>;
    caption?: ValidationFunction<string>;
    post_url?: ValidationFunction<string>;
    profile_url?: ValidationFunction<string>;
    status?: ValidationFunction<string>;
    metadata?: ValidationFunction<string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type PostCreateFormRowOverridesProps = {
    PostCreateFormRowGrid?: FormProps<GridProps>;
    RowGrid0?: FormProps<GridProps>;
    username?: FormProps<TextFieldProps>;
    caption?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
    status?: FormProps<SelectFieldProps>;
    metadata?: FormProps<TextAreaFieldProps>;
} & EscapeHatchProps;
export declare type PostCreateFormRowProps = React.PropsWithChildren<{
    overrides?: PostCreateFormRowOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: PostCreateFormRowInputValues) => PostCreateFormRowInputValues;
    onSuccess?: (fields: PostCreateFormRowInputValues) => void;
    onError?: (fields: PostCreateFormRowInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: PostCreateFormRowInputValues) => PostCreateFormRowInputValues;
    onValidate?: PostCreateFormRowValidationValues;
} & React.CSSProperties>;
export default function PostCreateFormRow(props: PostCreateFormRowProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should use proper field overrides for belongsTo relationship 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Member, Team } from \\"../models\\";
import {
  getOverrideProps,
  useDataStoreBinding,
} from \\"@aws-amplify/ui-react/internal\\";
import {
  Autocomplete,
  Badge,
  Button,
  Divider,
  Flex,
  Grid,
  Icon,
  ScrollView,
  Text,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  label,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
  defaultFieldValue,
  lengthLimit,
  getBadgeText,
}) {
  const { tokens } = useTheme();
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const [isEditing, setIsEditing] = React.useState();
  React.useEffect(() => {
    if (isEditing) {
      inputFieldRef?.current?.focus();
    }
  }, [isEditing]);
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (
      (currentFieldValue !== undefined ||
        currentFieldValue !== null ||
        currentFieldValue !== \\"\\") &&
      !hasError
    ) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
      setIsEditing(false);
    }
  };
  const arraySection = (
    <React.Fragment>
      <Text>{label}</Text>
      {!!items?.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(
                    getBadgeText ? getBadgeText(items[index]) : items[index]
                  );
                  setIsEditing(true);
                }}
              >
                {getBadgeText ? getBadgeText(value) : value.toString()}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
  if (lengthLimit !== undefined && items.length >= lengthLimit && !isEditing) {
    return arraySection;
  }
  return (
    <React.Fragment>
      {isEditing && children}
      {!isEditing ? (
        <>
          <Text>{label}</Text>
          <Button
            onClick={() => {
              setIsEditing(true);
            }}
          >
            Add item
          </Button>
        </>
      ) : (
        <Flex justifyContent=\\"flex-end\\">
          {(currentFieldValue || isEditing) && (
            <Button
              children=\\"Cancel\\"
              type=\\"button\\"
              size=\\"small\\"
              onClick={() => {
                setFieldValue(defaultFieldValue);
                setIsEditing(false);
                setSelectedBadgeIndex(undefined);
              }}
            ></Button>
          )}
          <Button
            size=\\"small\\"
            variation=\\"link\\"
            color={tokens.colors.brand.primary[80]}
            isDisabled={hasError}
            onClick={addItem}
          >
            {selectedBadgeIndex !== undefined ? \\"Save\\" : \\"Add\\"}
          </Button>
        </Flex>
      )}
      {arraySection}
    </React.Fragment>
  );
}
export default function MyMemberForm(props) {
  const {
    clearOnSuccess = true,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const initialValues = {
    name: undefined,
    team: undefined,
  };
  const [name, setName] = React.useState(initialValues.name);
  const [team, setTeam] = React.useState(initialValues.team);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(initialValues.name);
    setTeam(initialValues.team);
    setCurrentTeamValue(undefined);
    setCurrentTeamDisplayValue(\\"\\");
    setErrors({});
  };
  const [currentTeamDisplayValue, setCurrentTeamDisplayValue] =
    React.useState(\\"\\");
  const [currentTeamValue, setCurrentTeamValue] = React.useState(undefined);
  const teamRef = React.createRef();
  const teamRecords = useDataStoreBinding({
    type: \\"collection\\",
    model: Team,
  }).items;
  const getDisplayValue = {
    team: (record) => record?.name,
  };
  const validations = {
    name: [],
    team: [],
  };
  const runValidationTasks = async (
    fieldName,
    currentValue,
    getDisplayValue
  ) => {
    const value = getDisplayValue
      ? getDisplayValue(currentValue)
      : currentValue;
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          name,
          team,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(
                    fieldName,
                    item,
                    getDisplayValue[fieldName]
                  )
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(
                fieldName,
                modelFields[fieldName],
                getDisplayValue[fieldName]
              )
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Member(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
          if (clearOnSuccess) {
            resetStateValues();
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyMemberForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"RightAlignCTASubFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextField
        label=\\"Name\\"
        isRequired={false}
        isReadOnly={false}
        onChange={(e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              team,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <ArrayField
        lengthLimit={1}
        onChange={async (items) => {
          let value = items[0];
          if (onChange) {
            const modelFields = {
              name,
              team: value,
            };
            const result = onChange(modelFields);
            value = result?.team ?? value;
          }
          setTeam(value);
          setCurrentTeamValue(undefined);
          setCurrentTeamDisplayValue(\\"\\");
        }}
        currentFieldValue={currentTeamValue}
        label={\\"Team Label\\"}
        items={team ? [team] : []}
        hasError={errors.team?.hasError}
        getBadgeText={getDisplayValue.team}
        setFieldValue={setCurrentTeamDisplayValue}
        inputFieldRef={teamRef}
        defaultFieldValue={\\"\\"}
      >
        <Autocomplete
          label=\\"Team Label\\"
          isRequired={false}
          isReadOnly={false}
          value={currentTeamDisplayValue}
          options={teamRecords.map((r) => ({
            id: r.id,
            label: getDisplayValue.team?.(r) ?? r.id,
          }))}
          onSelect={({ id, label }) => {
            setCurrentTeamValue(teamRecords.find((r) => r.id === id));
            setCurrentTeamDisplayValue(label);
          }}
          onClear={() => {
            setCurrentTeamDisplayValue(\\"\\");
          }}
          onChange={(e) => {
            let { value } = e.target;
            if (errors.team?.hasError) {
              runValidationTasks(\\"team\\", value);
            }
            setCurrentTeamDisplayValue(value);
            setCurrentTeamValue(undefined);
          }}
          onBlur={() => runValidationTasks(\\"team\\", team)}
          errorMessage={errors.team?.errorMessage}
          hasError={errors.team?.hasError}
          ref={teamRef}
          {...getOverrideProps(overrides, \\"team\\")}
        ></Autocomplete>
      </ArrayField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should use proper field overrides for belongsTo relationship 2`] = `
"import * as React from \\"react\\";
import { Team } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { AutocompleteProps, GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type MyMemberFormInputValues = {
    name?: string;
    team?: Team;
};
export declare type MyMemberFormValidationValues = {
    name?: ValidationFunction<string>;
    team?: ValidationFunction<Team>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyMemberFormOverridesProps = {
    MyMemberFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    team?: FormProps<AutocompleteProps>;
} & EscapeHatchProps;
export declare type MyMemberFormProps = React.PropsWithChildren<{
    overrides?: MyMemberFormOverridesProps | undefined | null;
} & {
    clearOnSuccess?: boolean;
    onSubmit?: (fields: MyMemberFormInputValues) => MyMemberFormInputValues;
    onSuccess?: (fields: MyMemberFormInputValues) => void;
    onError?: (fields: MyMemberFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyMemberFormInputValues) => MyMemberFormInputValues;
    onValidate?: MyMemberFormValidationValues;
} & React.CSSProperties>;
export default function MyMemberForm(props: MyMemberFormProps): React.ReactElement;
"
`;
