// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`amplify form renderer tests custom form tests should render a custom backed form 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  Radio,
  RadioGroupField,
  SelectField,
  StepperField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
export default function CustomDataForm(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const [name, setName] = React.useState(undefined);
  const [email, setEmail] = React.useState(undefined);
  const [city, setCity] = React.useState(undefined);
  const [category, setCategory] = React.useState(undefined);
  const [pages, setPages] = React.useState(0);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(undefined);
    setEmail(undefined);
    setCity(undefined);
    setCategory(undefined);
    setPages(0);
    setErrors({});
  };
  const validations = {
    name: [{ type: \\"Required\\" }],
    email: [{ type: \\"Required\\" }],
    city: [],
    category: [],
    pages: [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
          email,
          city,
          category,
          pages,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomDataForm\\")}
    >
      <TextField
        label=\\"name\\"
        isRequired={true}
        defaultValue=\\"John Doe\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              email,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            await runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <TextField
        label=\\"E-mail\\"
        isRequired={true}
        defaultValue=\\"johndoe@amplify.com\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email: value,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.email ?? value;
          }
          if (errors.email?.hasError) {
            await runValidationTasks(\\"email\\", value);
          }
          setEmail(value);
        }}
        onBlur={() => runValidationTasks(\\"email\\", email)}
        errorMessage={errors.email?.errorMessage}
        hasError={errors.email?.hasError}
        {...getOverrideProps(overrides, \\"email\\")}
      ></TextField>
      <SelectField
        label=\\"Label\\"
        placeholder=\\"Please select an option\\"
        value={city}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city: value,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.city ?? value;
          }
          if (errors.city?.hasError) {
            await runValidationTasks(\\"city\\", value);
          }
          setCity(value);
        }}
        onBlur={() => runValidationTasks(\\"city\\", city)}
        errorMessage={errors.city?.errorMessage}
        hasError={errors.city?.hasError}
        {...getOverrideProps(overrides, \\"city\\")}
      >
        <option
          children=\\"Los Angeles\\"
          value=\\"Los Angeles\\"
          {...getOverrideProps(overrides, \\"cityoption0\\")}
        ></option>
        <option
          children=\\"Houston\\"
          value=\\"Houston\\"
          {...getOverrideProps(overrides, \\"cityoption1\\")}
        ></option>
        <option
          children=\\"New York\\"
          value=\\"New York\\"
          selected={true}
          {...getOverrideProps(overrides, \\"cityoption2\\")}
        ></option>
      </SelectField>
      <RadioGroupField
        label=\\"Label\\"
        name=\\"fieldName\\"
        defaultValue=\\"Hobbies\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category: value,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.category ?? value;
          }
          if (errors.category?.hasError) {
            await runValidationTasks(\\"category\\", value);
          }
          setCategory(value);
        }}
        onBlur={() => runValidationTasks(\\"category\\", category)}
        errorMessage={errors.category?.errorMessage}
        hasError={errors.category?.hasError}
        {...getOverrideProps(overrides, \\"category\\")}
      >
        <Radio
          children=\\"Hobbies\\"
          value=\\"Hobbies\\"
          {...getOverrideProps(overrides, \\"categoryRadio0\\")}
        ></Radio>
        <Radio
          children=\\"Travel\\"
          value=\\"Travel\\"
          {...getOverrideProps(overrides, \\"categoryRadio1\\")}
        ></Radio>
        <Radio
          children=\\"Health\\"
          value=\\"Health\\"
          {...getOverrideProps(overrides, \\"categoryRadio2\\")}
        ></Radio>
      </RadioGroupField>
      <StepperField
        label=\\"Label\\"
        value={pages}
        onStepChange={async (e) => {
          let value = e;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category,
              pages: value,
            };
            const result = onChange(modelFields);
            value = result?.pages ?? value;
          }
          if (errors.pages?.hasError) {
            await runValidationTasks(\\"pages\\", value);
          }
          setPages(value);
        }}
        onBlur={() => runValidationTasks(\\"pages\\", pages)}
        errorMessage={errors.pages?.errorMessage}
        hasError={errors.pages?.hasError}
        {...getOverrideProps(overrides, \\"pages\\")}
      ></StepperField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"empty\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"go back\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"create\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests custom form tests should render a custom backed form 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, RadioGroupFieldProps, SelectFieldProps, StepperFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type CustomDataFormInputValues<useBase extends boolean = true> = {
    name?: UseBaseOrValidationType<useBase, string>;
    email?: UseBaseOrValidationType<useBase, string>;
    city?: UseBaseOrValidationType<useBase, string>;
    category?: UseBaseOrValidationType<useBase, string>;
    pages?: UseBaseOrValidationType<useBase, number>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomDataFormOverridesProps = {
    CustomDataFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    email?: FormProps<TextFieldProps>;
    city?: FormProps<SelectFieldProps>;
    category?: FormProps<RadioGroupFieldProps>;
    pages?: FormProps<StepperFieldProps>;
} & EscapeHatchProps;
export declare type CustomDataFormProps = React.PropsWithChildren<{
    overrides?: CustomDataFormOverridesProps | undefined | null;
} & {
    onSubmit: (fields: CustomDataFormInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomDataFormInputValues) => CustomDataFormInputValues;
    onValidate?: CustomDataFormInputValues<false>;
}>;
export default function CustomDataForm(props: CustomDataFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests custom form tests should render a custom backed form 3`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  Radio,
  RadioGroupField,
  SelectField,
  StepperField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
export default function CustomDataForm(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const [name, setName] = React.useState(undefined);
  const [email, setEmail] = React.useState(undefined);
  const [city, setCity] = React.useState(undefined);
  const [category, setCategory] = React.useState(undefined);
  const [pages, setPages] = React.useState(0);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(undefined);
    setEmail(undefined);
    setCity(undefined);
    setCategory(undefined);
    setPages(0);
    setErrors({});
  };
  React.useEffect(() => {
    if (initialData) {
      setName(initialData.name);
      setEmail(initialData.email);
      setCity(initialData.city);
      setCategory(initialData.category);
      setPages(initialData.pages);
    }
  }, []);
  const validations = {
    name: [{ type: \\"Required\\" }],
    email: [{ type: \\"Required\\" }],
    city: [],
    category: [],
    pages: [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
          email,
          city,
          category,
          pages,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomDataForm\\")}
    >
      <TextField
        label=\\"name\\"
        isRequired={true}
        defaultValue=\\"John Doe\\"
        defaultValue={name}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
              email,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            await runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <TextField
        label=\\"E-mail\\"
        isRequired={true}
        defaultValue=\\"johndoe@amplify.com\\"
        defaultValue={email}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email: value,
              city,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.email ?? value;
          }
          if (errors.email?.hasError) {
            await runValidationTasks(\\"email\\", value);
          }
          setEmail(value);
        }}
        onBlur={() => runValidationTasks(\\"email\\", email)}
        errorMessage={errors.email?.errorMessage}
        hasError={errors.email?.hasError}
        {...getOverrideProps(overrides, \\"email\\")}
      ></TextField>
      <SelectField
        label=\\"Label\\"
        placeholder=\\"Please select an option\\"
        value={city}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city: value,
              category,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.city ?? value;
          }
          if (errors.city?.hasError) {
            await runValidationTasks(\\"city\\", value);
          }
          setCity(value);
        }}
        onBlur={() => runValidationTasks(\\"city\\", city)}
        errorMessage={errors.city?.errorMessage}
        hasError={errors.city?.hasError}
        {...getOverrideProps(overrides, \\"city\\")}
      >
        <option
          children=\\"Los Angeles\\"
          value=\\"Los Angeles\\"
          {...getOverrideProps(overrides, \\"cityoption0\\")}
        ></option>
        <option
          children=\\"Houston\\"
          value=\\"Houston\\"
          {...getOverrideProps(overrides, \\"cityoption1\\")}
        ></option>
        <option
          children=\\"New York\\"
          value=\\"New York\\"
          selected={true}
          {...getOverrideProps(overrides, \\"cityoption2\\")}
        ></option>
      </SelectField>
      <RadioGroupField
        label=\\"Label\\"
        name=\\"fieldName\\"
        defaultValue=\\"Hobbies\\"
        defaultValue={category}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category: value,
              pages,
            };
            const result = onChange(modelFields);
            value = result?.category ?? value;
          }
          if (errors.category?.hasError) {
            await runValidationTasks(\\"category\\", value);
          }
          setCategory(value);
        }}
        onBlur={() => runValidationTasks(\\"category\\", category)}
        errorMessage={errors.category?.errorMessage}
        hasError={errors.category?.hasError}
        {...getOverrideProps(overrides, \\"category\\")}
      >
        <Radio
          children=\\"Hobbies\\"
          value=\\"Hobbies\\"
          {...getOverrideProps(overrides, \\"categoryRadio0\\")}
        ></Radio>
        <Radio
          children=\\"Travel\\"
          value=\\"Travel\\"
          {...getOverrideProps(overrides, \\"categoryRadio1\\")}
        ></Radio>
        <Radio
          children=\\"Health\\"
          value=\\"Health\\"
          {...getOverrideProps(overrides, \\"categoryRadio2\\")}
        ></Radio>
      </RadioGroupField>
      <StepperField
        label=\\"Label\\"
        value={pages}
        onStepChange={async (e) => {
          let value = e;
          if (onChange) {
            const modelFields = {
              name,
              email,
              city,
              category,
              pages: value,
            };
            const result = onChange(modelFields);
            value = result?.pages ?? value;
          }
          if (errors.pages?.hasError) {
            await runValidationTasks(\\"pages\\", value);
          }
          setPages(value);
        }}
        onBlur={() => runValidationTasks(\\"pages\\", pages)}
        errorMessage={errors.pages?.errorMessage}
        hasError={errors.pages?.hasError}
        {...getOverrideProps(overrides, \\"pages\\")}
      ></StepperField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"empty\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"go back\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"create\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests custom form tests should render a custom backed form 4`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, RadioGroupFieldProps, SelectFieldProps, StepperFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type CustomDataFormInputValues<useBase extends boolean = true> = {
    name?: UseBaseOrValidationType<useBase, string>;
    email?: UseBaseOrValidationType<useBase, string>;
    city?: UseBaseOrValidationType<useBase, string>;
    category?: UseBaseOrValidationType<useBase, string>;
    pages?: UseBaseOrValidationType<useBase, number>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomDataFormOverridesProps = {
    CustomDataFormGrid?: FormProps<GridProps>;
    name?: FormProps<TextFieldProps>;
    email?: FormProps<TextFieldProps>;
    city?: FormProps<SelectFieldProps>;
    category?: FormProps<RadioGroupFieldProps>;
    pages?: FormProps<StepperFieldProps>;
} & EscapeHatchProps;
export declare type CustomDataFormProps = React.PropsWithChildren<{
    overrides?: CustomDataFormOverridesProps | undefined | null;
} & {
    initialData?: CustomDataFormInputValues;
    onSubmit: (fields: CustomDataFormInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomDataFormInputValues) => CustomDataFormInputValues;
    onValidate?: CustomDataFormInputValues<false>;
}>;
export default function CustomDataForm(props: CustomDataFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests custom form tests should render nested json fields 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  Heading,
  TextField,
  useTheme,
} from \\"@aws-amplify/ui-react\\";
export default function NestedJson(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const { tokens } = useTheme();
  const [firstName, setFirstName] = React.useState(undefined);
  const [lastName, setLastName] = React.useState(undefined);
  const [bio, setBio] = React.useState({});
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setFirstName(undefined);
    setLastName(undefined);
    setBio({});
    setErrors({});
  };
  const validations = {
    firstName: [],
    lastName: [],
    \\"bio.favoriteQuote\\": [],
    \\"bio.favoriteAnimal\\": [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap={tokens.space.large.value}
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          firstName,
          lastName,
          bio,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"NestedJson\\")}
    >
      <TextField
        label=\\"firstName\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName: value,
              lastName,
              bio,
            };
            const result = onChange(modelFields);
            value = result?.firstName ?? value;
          }
          if (errors.firstName?.hasError) {
            await runValidationTasks(\\"firstName\\", value);
          }
          setFirstName(value);
        }}
        onBlur={() => runValidationTasks(\\"firstName\\", firstName)}
        errorMessage={errors.firstName?.errorMessage}
        hasError={errors.firstName?.hasError}
        {...getOverrideProps(overrides, \\"firstName\\")}
      ></TextField>
      <TextField
        label=\\"lastName\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              lastName: value,
              bio,
            };
            const result = onChange(modelFields);
            value = result?.lastName ?? value;
          }
          if (errors.lastName?.hasError) {
            await runValidationTasks(\\"lastName\\", value);
          }
          setLastName(value);
        }}
        onBlur={() => runValidationTasks(\\"lastName\\", lastName)}
        errorMessage={errors.lastName?.errorMessage}
        hasError={errors.lastName?.hasError}
        {...getOverrideProps(overrides, \\"lastName\\")}
      ></TextField>
      <Heading
        level={3}
        children=\\"bio\\"
        {...getOverrideProps(overrides, \\"bio\\")}
      ></Heading>
      <TextField
        label=\\"favoriteQuote\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              lastName,
              bio: { ...bio, favoriteQuote: value },
            };
            const result = onChange(modelFields);
            value = result?.bio?.favoriteQuote ?? value;
          }
          if (errors.bio.favoriteQuote?.hasError) {
            await runValidationTasks(\\"bio.favoriteQuote\\", value);
          }
          setBio({ ...bio, favoriteQuote: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favoriteQuote\\", bio.favoriteQuote)
        }
        errorMessage={errors[\\"bio.favoriteQuote\\"]?.errorMessage}
        hasError={errors[\\"bio.favoriteQuote\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favoriteQuote\\")}
      ></TextField>
      <TextField
        label=\\"favoriteAnimal\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              lastName,
              bio: { ...bio, favoriteAnimal: value },
            };
            const result = onChange(modelFields);
            value = result?.bio?.favoriteAnimal ?? value;
          }
          if (errors.bio.favoriteAnimal?.hasError) {
            await runValidationTasks(\\"bio.favoriteAnimal\\", value);
          }
          setBio({ ...bio, favoriteAnimal: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favoriteAnimal\\", bio.favoriteAnimal)
        }
        errorMessage={errors[\\"bio.favoriteAnimal\\"]?.errorMessage}
        hasError={errors[\\"bio.favoriteAnimal\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favoriteAnimal\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests custom form tests should render nested json fields 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, HeadingProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type NestedJsonInputValues<useBase extends boolean = true> = {
    firstName?: UseBaseOrValidationType<useBase, string>;
    lastName?: UseBaseOrValidationType<useBase, string>;
    bio?: {
        favoriteQuote?: UseBaseOrValidationType<useBase, string>;
        favoriteAnimal?: UseBaseOrValidationType<useBase, string>;
    };
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type NestedJsonOverridesProps = {
    NestedJsonGrid?: FormProps<GridProps>;
    firstName?: FormProps<TextFieldProps>;
    lastName?: FormProps<TextFieldProps>;
    bio?: FormProps<HeadingProps>;
    \\"bio.favoriteQuote\\"?: FormProps<TextFieldProps>;
    \\"bio.favoriteAnimal\\"?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type NestedJsonProps = React.PropsWithChildren<{
    overrides?: NestedJsonOverridesProps | undefined | null;
} & {
    onSubmit: (fields: NestedJsonInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: NestedJsonInputValues) => NestedJsonInputValues;
    onValidate?: NestedJsonInputValues<false>;
}>;
export default function NestedJson(props: NestedJsonProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests custom form tests should render nested json fields 3`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import { Button, Flex, Grid, Heading, TextField } from \\"@aws-amplify/ui-react\\";
export default function NestedJson(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const [firstName, setFirstName] = React.useState(undefined);
  const [lastName, setLastName] = React.useState(undefined);
  const [bio, setBio] = React.useState({});
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setFirstName(undefined);
    setLastName(undefined);
    setBio({});
    setErrors({});
  };
  React.useEffect(() => {
    if (initialData) {
      setFirstName(initialData.firstName);
      setLastName(initialData.lastName);
      setBio(initialData.bio);
    }
  }, []);
  const validations = {
    firstName: [],
    lastName: [],
    \\"bio.favoriteQuote\\": [],
    \\"bio.favoriteAnimal\\": [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          firstName,
          lastName,
          bio,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"NestedJson\\")}
    >
      <TextField
        label=\\"firstName\\"
        defaultValue={firstName}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName: value,
              lastName,
              bio,
            };
            const result = onChange(modelFields);
            value = result?.firstName ?? value;
          }
          if (errors.firstName?.hasError) {
            await runValidationTasks(\\"firstName\\", value);
          }
          setFirstName(value);
        }}
        onBlur={() => runValidationTasks(\\"firstName\\", firstName)}
        errorMessage={errors.firstName?.errorMessage}
        hasError={errors.firstName?.hasError}
        {...getOverrideProps(overrides, \\"firstName\\")}
      ></TextField>
      <TextField
        label=\\"lastName\\"
        defaultValue={lastName}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              lastName: value,
              bio,
            };
            const result = onChange(modelFields);
            value = result?.lastName ?? value;
          }
          if (errors.lastName?.hasError) {
            await runValidationTasks(\\"lastName\\", value);
          }
          setLastName(value);
        }}
        onBlur={() => runValidationTasks(\\"lastName\\", lastName)}
        errorMessage={errors.lastName?.errorMessage}
        hasError={errors.lastName?.hasError}
        {...getOverrideProps(overrides, \\"lastName\\")}
      ></TextField>
      <Heading
        level={3}
        children=\\"bio\\"
        {...getOverrideProps(overrides, \\"bio\\")}
      ></Heading>
      <TextField
        label=\\"favoriteQuote\\"
        defaultValue={bio.favoriteQuote}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              lastName,
              bio: { ...bio, favoriteQuote: value },
            };
            const result = onChange(modelFields);
            value = result?.bio?.favoriteQuote ?? value;
          }
          if (errors.bio.favoriteQuote?.hasError) {
            await runValidationTasks(\\"bio.favoriteQuote\\", value);
          }
          setBio({ ...bio, favoriteQuote: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favoriteQuote\\", bio.favoriteQuote)
        }
        errorMessage={errors[\\"bio.favoriteQuote\\"]?.errorMessage}
        hasError={errors[\\"bio.favoriteQuote\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favoriteQuote\\")}
      ></TextField>
      <TextField
        label=\\"favoriteAnimal\\"
        defaultValue={bio.favoriteAnimal}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              firstName,
              lastName,
              bio: { ...bio, favoriteAnimal: value },
            };
            const result = onChange(modelFields);
            value = result?.bio?.favoriteAnimal ?? value;
          }
          if (errors.bio.favoriteAnimal?.hasError) {
            await runValidationTasks(\\"bio.favoriteAnimal\\", value);
          }
          setBio({ ...bio, favoriteAnimal: value });
        }}
        onBlur={() =>
          runValidationTasks(\\"bio.favoriteAnimal\\", bio.favoriteAnimal)
        }
        errorMessage={errors[\\"bio.favoriteAnimal\\"]?.errorMessage}
        hasError={errors[\\"bio.favoriteAnimal\\"]?.hasError}
        {...getOverrideProps(overrides, \\"bio.favoriteAnimal\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests custom form tests should render nested json fields 4`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, HeadingProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type NestedJsonInputValues<useBase extends boolean = true> = {
    firstName?: UseBaseOrValidationType<useBase, string>;
    lastName?: UseBaseOrValidationType<useBase, string>;
    bio?: {
        favoriteQuote?: UseBaseOrValidationType<useBase, string>;
        favoriteAnimal?: UseBaseOrValidationType<useBase, string>;
    };
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type NestedJsonOverridesProps = {
    NestedJsonGrid?: FormProps<GridProps>;
    firstName?: FormProps<TextFieldProps>;
    lastName?: FormProps<TextFieldProps>;
    bio?: FormProps<HeadingProps>;
    \\"bio.favoriteQuote\\"?: FormProps<TextFieldProps>;
    \\"bio.favoriteAnimal\\"?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type NestedJsonProps = React.PropsWithChildren<{
    overrides?: NestedJsonOverridesProps | undefined | null;
} & {
    initialData?: NestedJsonInputValues;
    onSubmit: (fields: NestedJsonInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: NestedJsonInputValues) => NestedJsonInputValues;
    onValidate?: NestedJsonInputValues<false>;
}>;
export default function NestedJson(props: NestedJsonProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests custom form tests should render sectional elements 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Divider,
  Flex,
  Grid,
  Heading,
  Text,
  TextField,
} from \\"@aws-amplify/ui-react\\";
export default function CustomWithSectionalElements(props) {
  const { onSubmit, onCancel, onValidate, onChange, overrides, ...rest } =
    props;
  const [name, setName] = React.useState(undefined);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setName(undefined);
    setErrors({});
  };
  const validations = {
    name: [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        const modelFields = {
          name,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        await onSubmit(modelFields);
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"CustomWithSectionalElements\\")}
    >
      <Heading
        level={2}
        children=\\"Create a Post\\"
        {...getOverrideProps(overrides, \\"myHeading\\")}
      ></Heading>
      <TextField
        label=\\"Label\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              name: value,
            };
            const result = onChange(modelFields);
            value = result?.name ?? value;
          }
          if (errors.name?.hasError) {
            await runValidationTasks(\\"name\\", value);
          }
          setName(value);
        }}
        onBlur={() => runValidationTasks(\\"name\\", name)}
        errorMessage={errors.name?.errorMessage}
        hasError={errors.name?.hasError}
        {...getOverrideProps(overrides, \\"name\\")}
      ></TextField>
      <Text
        children=\\"Did you put your name above?\\"
        {...getOverrideProps(overrides, \\"myText\\")}
      ></Text>
      <Divider
        orientation=\\"horizontal\\"
        {...getOverrideProps(overrides, \\"myDivider\\")}
      ></Divider>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests custom form tests should render sectional elements 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { DividerProps, GridProps, HeadingProps, TextFieldProps, TextProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type CustomWithSectionalElementsInputValues<useBase extends boolean = true> = {
    name?: UseBaseOrValidationType<useBase, string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type CustomWithSectionalElementsOverridesProps = {
    CustomWithSectionalElementsGrid?: FormProps<GridProps>;
    myHeading?: FormProps<HeadingProps>;
    name?: FormProps<TextFieldProps>;
    myText?: FormProps<TextProps>;
    myDivider?: FormProps<DividerProps>;
} & EscapeHatchProps;
export declare type CustomWithSectionalElementsProps = React.PropsWithChildren<{
    overrides?: CustomWithSectionalElementsOverridesProps | undefined | null;
} & {
    onSubmit: (fields: CustomWithSectionalElementsInputValues) => void;
    onCancel?: () => void;
    onChange?: (fields: CustomWithSectionalElementsInputValues) => CustomWithSectionalElementsInputValues;
    onValidate?: CustomWithSectionalElementsInputValues<false>;
}>;
export default function CustomWithSectionalElements(props: CustomWithSectionalElementsProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import { Button, Flex, Grid, TextField } from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
export default function MyPostForm(props) {
  const {
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const [caption, setCaption] = React.useState(undefined);
  const [username, setUsername] = React.useState(undefined);
  const [post_url, setPost_url] = React.useState(undefined);
  const [profile_url, setProfile_url] = React.useState(undefined);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setCaption(undefined);
    setUsername(undefined);
    setPost_url(undefined);
    setProfile_url(undefined);
    setErrors({});
  };
  const validations = {
    caption: [],
    username: [],
    post_url: [{ type: \\"URL\\" }],
    profile_url: [{ type: \\"URL\\" }],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          caption,
          username,
          post_url,
          profile_url,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Post(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyPostForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextField
        label=\\"Caption\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption: value,
              username,
              post_url,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.caption ?? value;
          }
          if (errors.caption?.hasError) {
            await runValidationTasks(\\"caption\\", value);
          }
          setCaption(value);
        }}
        onBlur={() => runValidationTasks(\\"caption\\", caption)}
        errorMessage={errors.caption?.errorMessage}
        hasError={errors.caption?.hasError}
        {...getOverrideProps(overrides, \\"caption\\")}
      ></TextField>
      <TextField
        label=\\"Username\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username: value,
              post_url,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.username ?? value;
          }
          if (errors.username?.hasError) {
            await runValidationTasks(\\"username\\", value);
          }
          setUsername(value);
        }}
        onBlur={() => runValidationTasks(\\"username\\", username)}
        errorMessage={errors.username?.errorMessage}
        hasError={errors.username?.hasError}
        {...getOverrideProps(overrides, \\"username\\")}
      ></TextField>
      <TextField
        label=\\"Post url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username,
              post_url: value,
              profile_url,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            await runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              caption,
              username,
              post_url,
              profile_url: value,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            await runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a create form 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type MyPostFormInputValues<useBase extends boolean = true> = {
    caption?: UseBaseOrValidationType<useBase, string>;
    username?: UseBaseOrValidationType<useBase, string>;
    post_url?: UseBaseOrValidationType<useBase, string>;
    profile_url?: UseBaseOrValidationType<useBase, string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyPostFormOverridesProps = {
    MyPostFormGrid?: FormProps<GridProps>;
    caption?: FormProps<TextFieldProps>;
    username?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type MyPostFormProps = React.PropsWithChildren<{
    overrides?: MyPostFormOverridesProps | undefined | null;
} & {
    onSubmit?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onSuccess?: (fields: MyPostFormInputValues) => void;
    onError?: (fields: MyPostFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onValidate?: MyPostFormInputValues<false>;
}>;
export default function MyPostForm(props: MyPostFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should generate a update form 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  TextAreaField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
export default function MyPostForm(props) {
  const {
    id,
    post,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const [TextAreaFieldbbd63464, setTextAreaFieldbbd63464] =
    React.useState(undefined);
  const [caption, setCaption] = React.useState(undefined);
  const [username, setUsername] = React.useState(undefined);
  const [profile_url, setProfile_url] = React.useState(undefined);
  const [post_url, setPost_url] = React.useState(undefined);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setTextAreaFieldbbd63464(undefined);
    setCaption(undefined);
    setUsername(undefined);
    setProfile_url(undefined);
    setPost_url(undefined);
    setErrors({});
  };
  const [postRecord, setPostRecord] = React.useState(post);
  React.useEffect(() => {
    const queryData = async () => {
      const record = id ? await DataStore.query(Post, id) : post;
      if (record) {
        setPostRecord(record);
        setTextAreaFieldbbd63464(record.TextAreaFieldbbd63464);
        setCaption(record.caption);
        setUsername(record.username);
        setProfile_url(record.profile_url);
        setPost_url(record.post_url);
      }
    };
    queryData();
  }, [id, post]);
  const validations = {
    TextAreaFieldbbd63464: [],
    caption: [],
    username: [],
    profile_url: [{ type: \\"URL\\" }],
    post_url: [{ type: \\"URL\\" }],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          TextAreaFieldbbd63464,
          caption,
          username,
          profile_url,
          post_url,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(
            Post.copyOf(postRecord, (updated) => {
              Object.assign(updated, modelFields);
            })
          );
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"MyPostForm\\")}
    >
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
      <TextAreaField
        label=\\"Label\\"
        defaultValue={TextAreaFieldbbd63464}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464: value,
              caption,
              username,
              profile_url,
              post_url,
            };
            const result = onChange(modelFields);
            value = result?.TextAreaFieldbbd63464 ?? value;
          }
          if (errors.TextAreaFieldbbd63464?.hasError) {
            await runValidationTasks(\\"TextAreaFieldbbd63464\\", value);
          }
          setTextAreaFieldbbd63464(value);
        }}
        onBlur={() =>
          runValidationTasks(\\"TextAreaFieldbbd63464\\", TextAreaFieldbbd63464)
        }
        errorMessage={errors.TextAreaFieldbbd63464?.errorMessage}
        hasError={errors.TextAreaFieldbbd63464?.hasError}
        {...getOverrideProps(overrides, \\"TextAreaFieldbbd63464\\")}
      ></TextAreaField>
      <TextField
        label=\\"Caption\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={caption}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption: value,
              username,
              profile_url,
              post_url,
            };
            const result = onChange(modelFields);
            value = result?.caption ?? value;
          }
          if (errors.caption?.hasError) {
            await runValidationTasks(\\"caption\\", value);
          }
          setCaption(value);
        }}
        onBlur={() => runValidationTasks(\\"caption\\", caption)}
        errorMessage={errors.caption?.errorMessage}
        hasError={errors.caption?.hasError}
        {...getOverrideProps(overrides, \\"caption\\")}
      ></TextField>
      <TextField
        label=\\"Username\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={username}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username: value,
              profile_url,
              post_url,
            };
            const result = onChange(modelFields);
            value = result?.username ?? value;
          }
          if (errors.username?.hasError) {
            await runValidationTasks(\\"username\\", value);
          }
          setUsername(value);
        }}
        onBlur={() => runValidationTasks(\\"username\\", username)}
        errorMessage={errors.username?.errorMessage}
        hasError={errors.username?.hasError}
        {...getOverrideProps(overrides, \\"username\\")}
      ></TextField>
      <TextField
        label=\\"Profile url\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={profile_url}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username,
              profile_url: value,
              post_url,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            await runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
      <TextField
        label=\\"Post url\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={post_url}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              TextAreaFieldbbd63464,
              caption,
              username,
              profile_url,
              post_url: value,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            await runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should generate a update form 2`] = `
"import * as React from \\"react\\";
import { Post } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, TextAreaFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type MyPostFormInputValues<useBase extends boolean = true> = {
    TextAreaFieldbbd63464?: UseBaseOrValidationType<useBase, string>;
    caption?: UseBaseOrValidationType<useBase, string>;
    username?: UseBaseOrValidationType<useBase, string>;
    profile_url?: UseBaseOrValidationType<useBase, string>;
    post_url?: UseBaseOrValidationType<useBase, string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type MyPostFormOverridesProps = {
    MyPostFormGrid?: FormProps<GridProps>;
    TextAreaFieldbbd63464?: FormProps<TextAreaFieldProps>;
    caption?: FormProps<TextFieldProps>;
    username?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type MyPostFormProps = React.PropsWithChildren<{
    overrides?: MyPostFormOverridesProps | undefined | null;
} & {
    id?: string;
    post?: Post;
    onSubmit?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onSuccess?: (fields: MyPostFormInputValues) => void;
    onError?: (fields: MyPostFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: MyPostFormInputValues) => MyPostFormInputValues;
    onValidate?: MyPostFormInputValues<false>;
}>;
export default function MyPostForm(props: MyPostFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { InputGallery } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  CheckboxField,
  Divider,
  Flex,
  Grid,
  Icon,
  Radio,
  RadioGroupField,
  ScrollView,
  TextField,
  ToggleButton,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
}) {
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (currentFieldValue.length && !hasError) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
    }
  };
  return (
    <React.Fragment>
      {children}
      <Flex justifyContent=\\"flex-end\\">
        <Button
          children=\\"Cancel\\"
          type=\\"button\\"
          onClick={() => {
            setFieldValue(\\"\\");
          }}
        ></Button>
        <Button
          children=\\"Save\\"
          variation=\\"primary\\"
          isDisabled={hasError}
          onClick={addItem}
        ></Button>
      </Flex>
      {!!items.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(items[index]);
                  inputFieldRef?.current?.focus();
                }}
              >
                {value}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
}
export default function InputGalleryCreateForm(props) {
  const {
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const [num, setNum] = React.useState(undefined);
  const [rootbeer, setRootbeer] = React.useState(undefined);
  const [attend, setAttend] = React.useState(undefined);
  const [maybeSlide, setMaybeSlide] = React.useState(false);
  const [maybeCheck, setMaybeCheck] = React.useState(undefined);
  const [arrayTypeField, setArrayTypeField] = React.useState(undefined);
  const [timestamp, setTimestamp] = React.useState(undefined);
  const [ippy, setIppy] = React.useState(undefined);
  const [timeisnow, setTimeisnow] = React.useState(undefined);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setNum(undefined);
    setRootbeer(undefined);
    setAttend(undefined);
    setMaybeSlide(false);
    setMaybeCheck(undefined);
    setArrayTypeField(undefined);
    setCurrentArrayTypeFieldValue(undefined);
    setTimestamp(undefined);
    setIppy(undefined);
    setTimeisnow(undefined);
    setErrors({});
  };
  const [currentArrayTypeFieldValue, setCurrentArrayTypeFieldValue] =
    React.useState(\\"\\");
  const arrayTypeFieldRef = React.createRef();
  const validations = {
    num: [],
    rootbeer: [],
    attend: [{ type: \\"Required\\" }],
    maybeSlide: [],
    maybeCheck: [],
    arrayTypeField: [],
    timestamp: [],
    ippy: [{ type: \\"IpAddress\\" }],
    timeisnow: [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          num,
          rootbeer,
          attend,
          maybeSlide,
          maybeCheck,
          arrayTypeField,
          timestamp,
          ippy,
          timeisnow,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new InputGallery(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"InputGalleryCreateForm\\")}
    >
      <TextField
        label=\\"Num\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        onChange={async (e) => {
          let value = parseInt(e.target.value);
          if (onChange) {
            const modelFields = {
              num: value,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.num ?? value;
          }
          if (errors.num?.hasError) {
            await runValidationTasks(\\"num\\", value);
          }
          setNum(value);
        }}
        onBlur={() => runValidationTasks(\\"num\\", num)}
        errorMessage={errors.num?.errorMessage}
        hasError={errors.num?.hasError}
        {...getOverrideProps(overrides, \\"num\\")}
      ></TextField>
      <TextField
        label=\\"Rootbeer\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        onChange={async (e) => {
          let value = Number(e.target.value);
          if (onChange) {
            const modelFields = {
              num,
              rootbeer: value,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.rootbeer ?? value;
          }
          if (errors.rootbeer?.hasError) {
            await runValidationTasks(\\"rootbeer\\", value);
          }
          setRootbeer(value);
        }}
        onBlur={() => runValidationTasks(\\"rootbeer\\", rootbeer)}
        errorMessage={errors.rootbeer?.errorMessage}
        hasError={errors.rootbeer?.hasError}
        {...getOverrideProps(overrides, \\"rootbeer\\")}
      ></TextField>
      <RadioGroupField
        label=\\"Attend\\"
        name=\\"attend\\"
        isReadOnly={false}
        isRequired=\\"false\\"
        onChange={async (e) => {
          let value = e.target.value === \\"true\\";
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend: value,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.attend ?? value;
          }
          if (errors.attend?.hasError) {
            await runValidationTasks(\\"attend\\", value);
          }
          setAttend(value);
        }}
        onBlur={() => runValidationTasks(\\"attend\\", attend)}
        errorMessage={errors.attend?.errorMessage}
        hasError={errors.attend?.hasError}
        {...getOverrideProps(overrides, \\"attend\\")}
      >
        <Radio
          children=\\"Yes\\"
          value=\\"true\\"
          {...getOverrideProps(overrides, \\"attendRadio0\\")}
        ></Radio>
        <Radio
          children=\\"No\\"
          value=\\"false\\"
          {...getOverrideProps(overrides, \\"attendRadio1\\")}
        ></Radio>
      </RadioGroupField>
      <ToggleButton
        children=\\"Maybe slide\\"
        isDisabled={false}
        defaultPressed={false}
        isPressed={maybeSlide}
        onChange={async (e) => {
          let value = !maybeSlide;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide: value,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeSlide ?? value;
          }
          if (errors.maybeSlide?.hasError) {
            await runValidationTasks(\\"maybeSlide\\", value);
          }
          setMaybeSlide(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeSlide\\", maybeSlide)}
        errorMessage={errors.maybeSlide?.errorMessage}
        hasError={errors.maybeSlide?.hasError}
        {...getOverrideProps(overrides, \\"maybeSlide\\")}
      ></ToggleButton>
      <CheckboxField
        label=\\"Maybe check\\"
        name=\\"maybeCheck\\"
        value=\\"maybeCheck\\"
        isDisabled={false}
        defaultChecked={false}
        onChange={async (e) => {
          let value = e.target.checked;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck: value,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeCheck ?? value;
          }
          if (errors.maybeCheck?.hasError) {
            await runValidationTasks(\\"maybeCheck\\", value);
          }
          setMaybeCheck(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeCheck\\", maybeCheck)}
        errorMessage={errors.maybeCheck?.errorMessage}
        hasError={errors.maybeCheck?.hasError}
        {...getOverrideProps(overrides, \\"maybeCheck\\")}
      ></CheckboxField>
      <ArrayField
        onChange={async (items) => {
          setArrayTypeField(items);
          setCurrentArrayTypeFieldValue(\\"\\");
        }}
        currentFieldValue={currentArrayTypeFieldValue}
        items={arrayTypeField}
        hasError={errors.arrayTypeField?.hasError}
        setFieldValue={setCurrentArrayTypeFieldValue}
        inputFieldRef={arrayTypeFieldRef}
      >
        <TextField
          label=\\"Array type field\\"
          isRequired={false}
          isReadOnly={false}
          onChange={async (e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                num,
                rootbeer,
                attend,
                maybeSlide,
                maybeCheck,
                arrayTypeField: value,
                timestamp,
                ippy,
                timeisnow,
              };
              const result = onChange(modelFields);
              value = result?.arrayTypeField ?? value;
            }
            if (errors.arrayTypeField?.hasError) {
              await runValidationTasks(\\"arrayTypeField\\", value);
            }
            setCurrentArrayTypeFieldValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"arrayTypeField\\", currentArrayTypeFieldValue)
          }
          errorMessage={errors.arrayTypeField?.errorMessage}
          hasError={errors.arrayTypeField?.hasError}
          value={currentArrayTypeFieldValue}
          ref={arrayTypeFieldRef}
          {...getOverrideProps(overrides, \\"arrayTypeField\\")}
        ></TextField>
      </ArrayField>
      <TextField
        label=\\"Timestamp\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"datetime-local\\"
        onChange={async (e) => {
          let value = Number(new Date(e.target.value));
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp: value,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.timestamp ?? value;
          }
          if (errors.timestamp?.hasError) {
            await runValidationTasks(\\"timestamp\\", value);
          }
          setTimestamp(value);
        }}
        onBlur={() => runValidationTasks(\\"timestamp\\", timestamp)}
        errorMessage={errors.timestamp?.errorMessage}
        hasError={errors.timestamp?.hasError}
        {...getOverrideProps(overrides, \\"timestamp\\")}
      ></TextField>
      <TextField
        label=\\"Ippy\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy: value,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.ippy ?? value;
          }
          if (errors.ippy?.hasError) {
            await runValidationTasks(\\"ippy\\", value);
          }
          setIppy(value);
        }}
        onBlur={() => runValidationTasks(\\"ippy\\", ippy)}
        errorMessage={errors.ippy?.errorMessage}
        hasError={errors.ippy?.hasError}
        {...getOverrideProps(overrides, \\"ippy\\")}
      ></TextField>
      <TextField
        label=\\"Timeisnow\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"time\\"
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow: value,
            };
            const result = onChange(modelFields);
            value = result?.timeisnow ?? value;
          }
          if (errors.timeisnow?.hasError) {
            await runValidationTasks(\\"timeisnow\\", value);
          }
          setTimeisnow(value);
        }}
        onBlur={() => runValidationTasks(\\"timeisnow\\", timeisnow)}
        errorMessage={errors.timeisnow?.errorMessage}
        hasError={errors.timeisnow?.hasError}
        {...getOverrideProps(overrides, \\"timeisnow\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { CheckboxFieldProps, GridProps, RadioGroupFieldProps, TextFieldProps, ToggleButtonProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type InputGalleryCreateFormInputValues<useBase extends boolean = true> = {
    num?: UseBaseOrValidationType<useBase, number>;
    rootbeer?: UseBaseOrValidationType<useBase, number>;
    attend?: UseBaseOrValidationType<useBase, boolean>;
    maybeSlide?: UseBaseOrValidationType<useBase, boolean>;
    maybeCheck?: UseBaseOrValidationType<useBase, boolean>;
    arrayTypeField?: UseBaseOrValidationType<useBase, string>;
    timestamp?: UseBaseOrValidationType<useBase, number>;
    ippy?: UseBaseOrValidationType<useBase, string>;
    timeisnow?: UseBaseOrValidationType<useBase, string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type InputGalleryCreateFormOverridesProps = {
    InputGalleryCreateFormGrid?: FormProps<GridProps>;
    num?: FormProps<TextFieldProps>;
    rootbeer?: FormProps<TextFieldProps>;
    attend?: FormProps<RadioGroupFieldProps>;
    maybeSlide?: FormProps<ToggleButtonProps>;
    maybeCheck?: FormProps<CheckboxFieldProps>;
    arrayTypeField?: FormProps<TextFieldProps>;
    timestamp?: FormProps<TextFieldProps>;
    ippy?: FormProps<TextFieldProps>;
    timeisnow?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type InputGalleryCreateFormProps = React.PropsWithChildren<{
    overrides?: InputGalleryCreateFormOverridesProps | undefined | null;
} & {
    onSubmit?: (fields: InputGalleryCreateFormInputValues) => InputGalleryCreateFormInputValues;
    onSuccess?: (fields: InputGalleryCreateFormInputValues) => void;
    onError?: (fields: InputGalleryCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: InputGalleryCreateFormInputValues) => InputGalleryCreateFormInputValues;
    onValidate?: InputGalleryCreateFormInputValues<false>;
}>;
export default function InputGalleryCreateForm(props: InputGalleryCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 3`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { InputGallery } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Badge,
  Button,
  CheckboxField,
  Divider,
  Flex,
  Grid,
  Icon,
  Radio,
  RadioGroupField,
  ScrollView,
  TextField,
  ToggleButton,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
function ArrayField({
  items = [],
  onChange,
  inputFieldRef,
  children,
  hasError,
  setFieldValue,
  currentFieldValue,
}) {
  const [selectedBadgeIndex, setSelectedBadgeIndex] = React.useState();
  const removeItem = async (removeIndex) => {
    const newItems = items.filter((value, index) => index !== removeIndex);
    await onChange(newItems);
    setSelectedBadgeIndex(undefined);
  };
  const addItem = async () => {
    if (currentFieldValue.length && !hasError) {
      const newItems = [...items];
      if (selectedBadgeIndex !== undefined) {
        newItems[selectedBadgeIndex] = currentFieldValue;
        setSelectedBadgeIndex(undefined);
      } else {
        newItems.push(currentFieldValue);
      }
      await onChange(newItems);
    }
  };
  return (
    <React.Fragment>
      {children}
      <Flex justifyContent=\\"flex-end\\">
        <Button
          children=\\"Cancel\\"
          type=\\"button\\"
          onClick={() => {
            setFieldValue(\\"\\");
          }}
        ></Button>
        <Button
          children=\\"Save\\"
          variation=\\"primary\\"
          isDisabled={hasError}
          onClick={addItem}
        ></Button>
      </Flex>
      {!!items.length && (
        <ScrollView height=\\"inherit\\" width=\\"inherit\\" maxHeight={\\"7rem\\"}>
          {items.map((value, index) => {
            return (
              <Badge
                key={index}
                style={{
                  cursor: \\"pointer\\",
                  alignItems: \\"center\\",
                  marginRight: 3,
                  marginTop: 3,
                  backgroundColor:
                    index === selectedBadgeIndex ? \\"#B8CEF9\\" : \\"\\",
                }}
                onClick={() => {
                  setSelectedBadgeIndex(index);
                  setFieldValue(items[index]);
                  inputFieldRef?.current?.focus();
                }}
              >
                {value}
                <Icon
                  style={{
                    cursor: \\"pointer\\",
                    paddingLeft: 3,
                    width: 20,
                    height: 20,
                  }}
                  viewBox={{ width: 20, height: 20 }}
                  paths={[
                    {
                      d: \\"M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z\\",
                      stroke: \\"black\\",
                    },
                  ]}
                  ariaLabel=\\"button\\"
                  onClick={(event) => {
                    event.stopPropagation();
                    removeItem(index);
                  }}
                />
              </Badge>
            );
          })}
        </ScrollView>
      )}
      <Divider orientation=\\"horizontal\\" marginTop={5} />
    </React.Fragment>
  );
}
export default function InputGalleryCreateForm(props) {
  const {
    id,
    inputGallery,
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const [num, setNum] = React.useState(undefined);
  const [rootbeer, setRootbeer] = React.useState(undefined);
  const [attend, setAttend] = React.useState(undefined);
  const [maybeSlide, setMaybeSlide] = React.useState(false);
  const [maybeCheck, setMaybeCheck] = React.useState(undefined);
  const [arrayTypeField, setArrayTypeField] = React.useState(undefined);
  const [timestamp, setTimestamp] = React.useState(undefined);
  const [ippy, setIppy] = React.useState(undefined);
  const [timeisnow, setTimeisnow] = React.useState(undefined);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setNum(undefined);
    setRootbeer(undefined);
    setAttend(undefined);
    setMaybeSlide(false);
    setMaybeCheck(undefined);
    setArrayTypeField(undefined);
    setCurrentArrayTypeFieldValue(undefined);
    setTimestamp(undefined);
    setIppy(undefined);
    setTimeisnow(undefined);
    setErrors({});
  };
  const [inputGalleryRecord, setInputGalleryRecord] =
    React.useState(inputGallery);
  React.useEffect(() => {
    const queryData = async () => {
      const record = id
        ? await DataStore.query(InputGallery, id)
        : inputGallery;
      if (record) {
        setInputGalleryRecord(record);
        setNum(record.num);
        setRootbeer(record.rootbeer);
        setAttend(record.attend);
        setMaybeSlide(record.maybeSlide);
        setMaybeCheck(record.maybeCheck);
        setArrayTypeField(record.arrayTypeField);
        setTimestamp(record.timestamp);
        setIppy(record.ippy);
        setTimeisnow(record.timeisnow);
      }
    };
    queryData();
  }, [id, inputGallery]);
  const [currentArrayTypeFieldValue, setCurrentArrayTypeFieldValue] =
    React.useState(\\"\\");
  const arrayTypeFieldRef = React.createRef();
  const validations = {
    num: [],
    rootbeer: [],
    attend: [{ type: \\"Required\\" }],
    maybeSlide: [],
    maybeCheck: [],
    arrayTypeField: [],
    timestamp: [],
    ippy: [{ type: \\"IpAddress\\" }],
    timeisnow: [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          num,
          rootbeer,
          attend,
          maybeSlide,
          maybeCheck,
          arrayTypeField,
          timestamp,
          ippy,
          timeisnow,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(
            InputGallery.copyOf(inputGalleryRecord, (updated) => {
              Object.assign(updated, modelFields);
            })
          );
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"InputGalleryCreateForm\\")}
    >
      <TextField
        label=\\"Num\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        defaultValue={num}
        onChange={async (e) => {
          let value = parseInt(e.target.value);
          if (onChange) {
            const modelFields = {
              num: value,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.num ?? value;
          }
          if (errors.num?.hasError) {
            await runValidationTasks(\\"num\\", value);
          }
          setNum(value);
        }}
        onBlur={() => runValidationTasks(\\"num\\", num)}
        errorMessage={errors.num?.errorMessage}
        hasError={errors.num?.hasError}
        {...getOverrideProps(overrides, \\"num\\")}
      ></TextField>
      <TextField
        label=\\"Rootbeer\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"number\\"
        defaultValue={rootbeer}
        onChange={async (e) => {
          let value = Number(e.target.value);
          if (onChange) {
            const modelFields = {
              num,
              rootbeer: value,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.rootbeer ?? value;
          }
          if (errors.rootbeer?.hasError) {
            await runValidationTasks(\\"rootbeer\\", value);
          }
          setRootbeer(value);
        }}
        onBlur={() => runValidationTasks(\\"rootbeer\\", rootbeer)}
        errorMessage={errors.rootbeer?.errorMessage}
        hasError={errors.rootbeer?.hasError}
        {...getOverrideProps(overrides, \\"rootbeer\\")}
      ></TextField>
      <RadioGroupField
        label=\\"Attend\\"
        name=\\"attend\\"
        isReadOnly={false}
        isRequired=\\"false\\"
        defaultValue={attend}
        onChange={async (e) => {
          let value = e.target.value === \\"true\\";
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend: value,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.attend ?? value;
          }
          if (errors.attend?.hasError) {
            await runValidationTasks(\\"attend\\", value);
          }
          setAttend(value);
        }}
        onBlur={() => runValidationTasks(\\"attend\\", attend)}
        errorMessage={errors.attend?.errorMessage}
        hasError={errors.attend?.hasError}
        {...getOverrideProps(overrides, \\"attend\\")}
      >
        <Radio
          children=\\"Yes\\"
          value=\\"true\\"
          {...getOverrideProps(overrides, \\"attendRadio0\\")}
        ></Radio>
        <Radio
          children=\\"No\\"
          value=\\"false\\"
          {...getOverrideProps(overrides, \\"attendRadio1\\")}
        ></Radio>
      </RadioGroupField>
      <ToggleButton
        children=\\"Maybe slide\\"
        isDisabled={false}
        defaultPressed={false}
        isPressed={maybeSlide}
        defaultValue={maybeSlide}
        onChange={async (e) => {
          let value = !maybeSlide;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide: value,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeSlide ?? value;
          }
          if (errors.maybeSlide?.hasError) {
            await runValidationTasks(\\"maybeSlide\\", value);
          }
          setMaybeSlide(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeSlide\\", maybeSlide)}
        errorMessage={errors.maybeSlide?.errorMessage}
        hasError={errors.maybeSlide?.hasError}
        {...getOverrideProps(overrides, \\"maybeSlide\\")}
      ></ToggleButton>
      <CheckboxField
        label=\\"Maybe check\\"
        name=\\"maybeCheck\\"
        value=\\"maybeCheck\\"
        isDisabled={false}
        defaultChecked={false}
        defaultValue={maybeCheck}
        onChange={async (e) => {
          let value = e.target.checked;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck: value,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.maybeCheck ?? value;
          }
          if (errors.maybeCheck?.hasError) {
            await runValidationTasks(\\"maybeCheck\\", value);
          }
          setMaybeCheck(value);
        }}
        onBlur={() => runValidationTasks(\\"maybeCheck\\", maybeCheck)}
        errorMessage={errors.maybeCheck?.errorMessage}
        hasError={errors.maybeCheck?.hasError}
        {...getOverrideProps(overrides, \\"maybeCheck\\")}
      ></CheckboxField>
      <ArrayField
        onChange={async (items) => {
          setArrayTypeField(items);
          setCurrentArrayTypeFieldValue(\\"\\");
        }}
        currentFieldValue={currentArrayTypeFieldValue}
        items={arrayTypeField}
        hasError={errors.arrayTypeField?.hasError}
        setFieldValue={setCurrentArrayTypeFieldValue}
        inputFieldRef={arrayTypeFieldRef}
      >
        <TextField
          label=\\"Array type field\\"
          isRequired={false}
          isReadOnly={false}
          onChange={async (e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                num,
                rootbeer,
                attend,
                maybeSlide,
                maybeCheck,
                arrayTypeField: value,
                timestamp,
                ippy,
                timeisnow,
              };
              const result = onChange(modelFields);
              value = result?.arrayTypeField ?? value;
            }
            if (errors.arrayTypeField?.hasError) {
              await runValidationTasks(\\"arrayTypeField\\", value);
            }
            setCurrentArrayTypeFieldValue(value);
          }}
          onBlur={() =>
            runValidationTasks(\\"arrayTypeField\\", currentArrayTypeFieldValue)
          }
          errorMessage={errors.arrayTypeField?.errorMessage}
          hasError={errors.arrayTypeField?.hasError}
          value={currentArrayTypeFieldValue}
          ref={arrayTypeFieldRef}
          {...getOverrideProps(overrides, \\"arrayTypeField\\")}
        ></TextField>
      </ArrayField>
      <TextField
        label=\\"Timestamp\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"datetime-local\\"
        defaultValue={timestamp}
        onChange={async (e) => {
          let value = Number(new Date(e.target.value));
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp: value,
              ippy,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.timestamp ?? value;
          }
          if (errors.timestamp?.hasError) {
            await runValidationTasks(\\"timestamp\\", value);
          }
          setTimestamp(value);
        }}
        onBlur={() => runValidationTasks(\\"timestamp\\", timestamp)}
        errorMessage={errors.timestamp?.errorMessage}
        hasError={errors.timestamp?.hasError}
        {...getOverrideProps(overrides, \\"timestamp\\")}
      ></TextField>
      <TextField
        label=\\"Ippy\\"
        isRequired={false}
        isReadOnly={false}
        defaultValue={ippy}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy: value,
              timeisnow,
            };
            const result = onChange(modelFields);
            value = result?.ippy ?? value;
          }
          if (errors.ippy?.hasError) {
            await runValidationTasks(\\"ippy\\", value);
          }
          setIppy(value);
        }}
        onBlur={() => runValidationTasks(\\"ippy\\", ippy)}
        errorMessage={errors.ippy?.errorMessage}
        hasError={errors.ippy?.hasError}
        {...getOverrideProps(overrides, \\"ippy\\")}
      ></TextField>
      <TextField
        label=\\"Timeisnow\\"
        isRequired={false}
        isReadOnly={false}
        type=\\"time\\"
        defaultValue={timeisnow}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              num,
              rootbeer,
              attend,
              maybeSlide,
              maybeCheck,
              arrayTypeField,
              timestamp,
              ippy,
              timeisnow: value,
            };
            const result = onChange(modelFields);
            value = result?.timeisnow ?? value;
          }
          if (errors.timeisnow?.hasError) {
            await runValidationTasks(\\"timeisnow\\", value);
          }
          setTimeisnow(value);
        }}
        onBlur={() => runValidationTasks(\\"timeisnow\\", timeisnow)}
        errorMessage={errors.timeisnow?.errorMessage}
        hasError={errors.timeisnow?.hasError}
        {...getOverrideProps(overrides, \\"timeisnow\\")}
      ></TextField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render a form with multiple date types 4`] = `
"import * as React from \\"react\\";
import { InputGallery } from \\"../models\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { CheckboxFieldProps, GridProps, RadioGroupFieldProps, TextFieldProps, ToggleButtonProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type InputGalleryCreateFormInputValues<useBase extends boolean = true> = {
    num?: UseBaseOrValidationType<useBase, number>;
    rootbeer?: UseBaseOrValidationType<useBase, number>;
    attend?: UseBaseOrValidationType<useBase, boolean>;
    maybeSlide?: UseBaseOrValidationType<useBase, boolean>;
    maybeCheck?: UseBaseOrValidationType<useBase, boolean>;
    arrayTypeField?: UseBaseOrValidationType<useBase, string>;
    timestamp?: UseBaseOrValidationType<useBase, number>;
    ippy?: UseBaseOrValidationType<useBase, string>;
    timeisnow?: UseBaseOrValidationType<useBase, string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type InputGalleryCreateFormOverridesProps = {
    InputGalleryCreateFormGrid?: FormProps<GridProps>;
    num?: FormProps<TextFieldProps>;
    rootbeer?: FormProps<TextFieldProps>;
    attend?: FormProps<RadioGroupFieldProps>;
    maybeSlide?: FormProps<ToggleButtonProps>;
    maybeCheck?: FormProps<CheckboxFieldProps>;
    arrayTypeField?: FormProps<TextFieldProps>;
    timestamp?: FormProps<TextFieldProps>;
    ippy?: FormProps<TextFieldProps>;
    timeisnow?: FormProps<TextFieldProps>;
} & EscapeHatchProps;
export declare type InputGalleryCreateFormProps = React.PropsWithChildren<{
    overrides?: InputGalleryCreateFormOverridesProps | undefined | null;
} & {
    id?: string;
    inputGallery?: InputGallery;
    onSubmit?: (fields: InputGalleryCreateFormInputValues) => InputGalleryCreateFormInputValues;
    onSuccess?: (fields: InputGalleryCreateFormInputValues) => void;
    onError?: (fields: InputGalleryCreateFormInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: InputGalleryCreateFormInputValues) => InputGalleryCreateFormInputValues;
    onValidate?: InputGalleryCreateFormInputValues<false>;
}>;
export default function InputGalleryCreateForm(props: InputGalleryCreateFormProps): React.ReactElement;
"
`;

exports[`amplify form renderer tests datastore form tests should render form with a two inputs in row 1`] = `
"/* eslint-disable */
import * as React from \\"react\\";
import { fetchByPath, validateField } from \\"./utils\\";
import { Post } from \\"../models\\";
import { getOverrideProps } from \\"@aws-amplify/ui-react/internal\\";
import {
  Button,
  Flex,
  Grid,
  SelectField,
  TextField,
} from \\"@aws-amplify/ui-react\\";
import { DataStore } from \\"aws-amplify\\";
export default function PostCreateFormRow(props) {
  const {
    onSuccess,
    onError,
    onSubmit,
    onCancel,
    onValidate,
    onChange,
    overrides,
    ...rest
  } = props;
  const [username, setUsername] = React.useState(undefined);
  const [caption, setCaption] = React.useState(undefined);
  const [post_url, setPost_url] = React.useState(undefined);
  const [profile_url, setProfile_url] = React.useState(undefined);
  const [status, setStatus] = React.useState(undefined);
  const [errors, setErrors] = React.useState({});
  const resetStateValues = () => {
    setUsername(undefined);
    setCaption(undefined);
    setPost_url(undefined);
    setProfile_url(undefined);
    setStatus(undefined);
    setErrors({});
  };
  const validations = {
    username: [
      {
        type: \\"GreaterThanChar\\",
        numValues: [2],
        validationMessage: \\"needs to be of length 2\\",
      },
    ],
    caption: [],
    post_url: [{ type: \\"URL\\" }],
    profile_url: [{ type: \\"URL\\" }],
    status: [],
  };
  const runValidationTasks = async (fieldName, value) => {
    let validationResponse = validateField(value, validations[fieldName]);
    const customValidator = fetchByPath(onValidate, fieldName);
    if (customValidator) {
      validationResponse = await customValidator(value, validationResponse);
    }
    setErrors((errors) => ({ ...errors, [fieldName]: validationResponse }));
    return validationResponse;
  };
  return (
    <Grid
      as=\\"form\\"
      rowGap=\\"15px\\"
      columnGap=\\"15px\\"
      padding=\\"20px\\"
      onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          username,
          caption,
          post_url,
          profile_url,
          status,
        };
        const validationResponses = await Promise.all(
          Object.keys(validations).reduce((promises, fieldName) => {
            if (Array.isArray(modelFields[fieldName])) {
              promises.push(
                ...modelFields[fieldName].map((item) =>
                  runValidationTasks(fieldName, item)
                )
              );
              return promises;
            }
            promises.push(
              runValidationTasks(fieldName, modelFields[fieldName])
            );
            return promises;
          }, [])
        );
        if (validationResponses.some((r) => r.hasError)) {
          return;
        }
        if (onSubmit) {
          modelFields = onSubmit(modelFields);
        }
        try {
          await DataStore.save(new Post(modelFields));
          if (onSuccess) {
            onSuccess(modelFields);
          }
        } catch (err) {
          if (onError) {
            onError(modelFields, err.message);
          }
        }
      }}
      {...rest}
      {...getOverrideProps(overrides, \\"PostCreateFormRow\\")}
    >
      <Grid
        columnGap=\\"inherit\\"
        rowGap=\\"inherit\\"
        templateColumns=\\"repeat(2, auto)\\"
        {...getOverrideProps(overrides, \\"RowGrid0\\")}
      >
        <TextField
          label=\\"Username\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"john\\"
          onChange={async (e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username: value,
                caption,
                post_url,
                profile_url,
                status,
              };
              const result = onChange(modelFields);
              value = result?.username ?? value;
            }
            if (errors.username?.hasError) {
              await runValidationTasks(\\"username\\", value);
            }
            setUsername(value);
          }}
          onBlur={() => runValidationTasks(\\"username\\", username)}
          errorMessage={errors.username?.errorMessage}
          hasError={errors.username?.hasError}
          {...getOverrideProps(overrides, \\"username\\")}
        ></TextField>
        <TextField
          label=\\"Caption\\"
          isRequired={false}
          isReadOnly={false}
          placeholder=\\"i love code\\"
          onChange={async (e) => {
            let { value } = e.target;
            if (onChange) {
              const modelFields = {
                username,
                caption: value,
                post_url,
                profile_url,
                status,
              };
              const result = onChange(modelFields);
              value = result?.caption ?? value;
            }
            if (errors.caption?.hasError) {
              await runValidationTasks(\\"caption\\", value);
            }
            setCaption(value);
          }}
          onBlur={() => runValidationTasks(\\"caption\\", caption)}
          errorMessage={errors.caption?.errorMessage}
          hasError={errors.caption?.hasError}
          {...getOverrideProps(overrides, \\"caption\\")}
        ></TextField>
      </Grid>
      <TextField
        label=\\"Post url\\"
        descriptiveText=\\"post url to use for the component\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url: value,
              profile_url,
              status,
            };
            const result = onChange(modelFields);
            value = result?.post_url ?? value;
          }
          if (errors.post_url?.hasError) {
            await runValidationTasks(\\"post_url\\", value);
          }
          setPost_url(value);
        }}
        onBlur={() => runValidationTasks(\\"post_url\\", post_url)}
        errorMessage={errors.post_url?.errorMessage}
        hasError={errors.post_url?.hasError}
        {...getOverrideProps(overrides, \\"post_url\\")}
      ></TextField>
      <TextField
        label=\\"Profile url\\"
        descriptiveText=\\"profile image url\\"
        isRequired={false}
        isReadOnly={false}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url,
              profile_url: value,
              status,
            };
            const result = onChange(modelFields);
            value = result?.profile_url ?? value;
          }
          if (errors.profile_url?.hasError) {
            await runValidationTasks(\\"profile_url\\", value);
          }
          setProfile_url(value);
        }}
        onBlur={() => runValidationTasks(\\"profile_url\\", profile_url)}
        errorMessage={errors.profile_url?.errorMessage}
        hasError={errors.profile_url?.hasError}
        {...getOverrideProps(overrides, \\"profile_url\\")}
      ></TextField>
      <SelectField
        label=\\"Label\\"
        placeholder=\\"Please select an option\\"
        value={status}
        onChange={async (e) => {
          let { value } = e.target;
          if (onChange) {
            const modelFields = {
              username,
              caption,
              post_url,
              profile_url,
              status: value,
            };
            const result = onChange(modelFields);
            value = result?.status ?? value;
          }
          if (errors.status?.hasError) {
            await runValidationTasks(\\"status\\", value);
          }
          setStatus(value);
        }}
        onBlur={() => runValidationTasks(\\"status\\", status)}
        errorMessage={errors.status?.errorMessage}
        hasError={errors.status?.hasError}
        {...getOverrideProps(overrides, \\"status\\")}
      ></SelectField>
      <Flex
        justifyContent=\\"space-between\\"
        {...getOverrideProps(overrides, \\"CTAFlex\\")}
      >
        <Button
          children=\\"Clear\\"
          type=\\"reset\\"
          onClick={resetStateValues}
          {...getOverrideProps(overrides, \\"ClearButton\\")}
        ></Button>
        <Flex {...getOverrideProps(overrides, \\"SubmitAndResetFlex\\")}>
          <Button
            children=\\"Cancel\\"
            type=\\"button\\"
            onClick={() => {
              onCancel && onCancel();
            }}
            {...getOverrideProps(overrides, \\"CancelButton\\")}
          ></Button>
          <Button
            children=\\"Submit\\"
            type=\\"submit\\"
            variation=\\"primary\\"
            isDisabled={Object.values(errors).some((e) => e?.hasError)}
            {...getOverrideProps(overrides, \\"SubmitButton\\")}
          ></Button>
        </Flex>
      </Flex>
    </Grid>
  );
}
"
`;

exports[`amplify form renderer tests datastore form tests should render form with a two inputs in row 2`] = `
"import * as React from \\"react\\";
import { EscapeHatchProps } from \\"@aws-amplify/ui-react/internal\\";
import { GridProps, SelectFieldProps, TextFieldProps } from \\"@aws-amplify/ui-react\\";
export declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
export declare type ValidationFunction<T> = (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
export declare type UseBaseOrValidationType<Flag, T> = Flag extends true ? T : ValidationFunction<T>;
export declare type PostCreateFormRowInputValues<useBase extends boolean = true> = {
    username?: UseBaseOrValidationType<useBase, string>;
    caption?: UseBaseOrValidationType<useBase, string>;
    post_url?: UseBaseOrValidationType<useBase, string>;
    profile_url?: UseBaseOrValidationType<useBase, string>;
    status?: UseBaseOrValidationType<useBase, string>;
};
export declare type FormProps<T> = Partial<T> & React.DOMAttributes<HTMLDivElement>;
export declare type PostCreateFormRowOverridesProps = {
    PostCreateFormRowGrid?: FormProps<GridProps>;
    RowGrid0?: FormProps<GridProps>;
    username?: FormProps<TextFieldProps>;
    caption?: FormProps<TextFieldProps>;
    post_url?: FormProps<TextFieldProps>;
    profile_url?: FormProps<TextFieldProps>;
    status?: FormProps<SelectFieldProps>;
} & EscapeHatchProps;
export declare type PostCreateFormRowProps = React.PropsWithChildren<{
    overrides?: PostCreateFormRowOverridesProps | undefined | null;
} & {
    onSubmit?: (fields: PostCreateFormRowInputValues) => PostCreateFormRowInputValues;
    onSuccess?: (fields: PostCreateFormRowInputValues) => void;
    onError?: (fields: PostCreateFormRowInputValues, errorMessage: string) => void;
    onCancel?: () => void;
    onChange?: (fields: PostCreateFormRowInputValues) => PostCreateFormRowInputValues;
    onValidate?: PostCreateFormRowInputValues<false>;
}>;
export default function PostCreateFormRow(props: PostCreateFormRowProps): React.ReactElement;
"
`;
